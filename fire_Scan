#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
å®‰å…¨å·¥å…·ï¼šURLå¨èƒæƒ…æŠ¥ä¸å¤‡æ¡ˆæ‰«æç³»ç»Ÿï¼ˆWindowså…¼å®¹ç‰ˆï¼‰
ä½œè€…ï¼šp1r07
ç‰ˆæœ¬ï¼š7.3.0ï¼ˆç§»é™¤tty/termios+åˆ é™¤URLæœ‰æ•ˆæ€§åˆ¤æ–­ï¼‰
ç‰¹æ€§ï¼šWindowså®Œå…¨å…¼å®¹ã€å³ä¾§æ‰“å°è¾“å‡ºã€é˜¿é‡Œäº‘APIå¤‡æ¡ˆæŸ¥è¯¢
"""

import os
import sys
import pkg_resources
import configparser
import json
import time
import hmac
import hashlib
import base64
import csv
import asyncio
import aiohttp
import random
import re
import socket
from urllib.parse import urlparse, urlunparse, quote_plus, urlencode
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from colorama import init, Fore, Style
import logging
from datetime import datetime
import tldextract

# Windowså…¼å®¹æ€§å¤„ç†ï¼ˆç§»é™¤Linux/macOSä¸“å±ä¾èµ–ï¼‰
if sys.platform.startswith('win'):
    import ctypes
    import msvcrt
    # å¯ç”¨Windowsç»ˆç«¯VT100é¢œè‰²æ”¯æŒ
    try:
        kernel32 = ctypes.windll.kernel32
        kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)  # ENABLE_VIRTUAL_TERMINAL_PROCESSING
    except Exception as e:
        print(f"{Fore.YELLOW}Windowsç»ˆç«¯é¢œè‰²æ”¯æŒå¯ç”¨å¤±è´¥: {str(e)}{Style.RESET_ALL}")

# -------------------------- å…¨å±€å¸¸é‡å®šä¹‰ --------------------------
# ç«ç„°ä¸»é¢˜é…ç½®
FIRE_COLORS = {
    "red": Fore.RED,
    "dark_red": Fore.LIGHTRED_EX,
    "orange": Fore.LIGHTYELLOW_EX,
    "yellow": Fore.YELLOW,
    "gold": Fore.LIGHTGREEN_EX,
    "blue": Fore.BLUE,
    "purple": Fore.MAGENTA,
    "reset": Style.RESET_ALL
}

FIRE_ICONS = {
    "flame": f"{FIRE_COLORS['red']}ğŸ”¥{FIRE_COLORS['reset']}",
    "success": f"{FIRE_COLORS['yellow']}âœ…{FIRE_COLORS['reset']}",
    "error": f"{FIRE_COLORS['red']}âŒ{FIRE_COLORS['reset']}",
    "info": f"{FIRE_COLORS['blue']}â„¹ï¸{FIRE_COLORS['reset']}",
    "warning": f"{FIRE_COLORS['orange']}âš ï¸{FIRE_COLORS['reset']}",
    "check": f"{FIRE_COLORS['yellow']}ğŸ”{FIRE_COLORS['reset']}",
    "icp": f"{FIRE_COLORS['blue']}ğŸ“‹{FIRE_COLORS['reset']}",
    "ip": f"{FIRE_COLORS['gold']}ğŸŒ{FIRE_COLORS['reset']}",
    "threat": f"{FIRE_COLORS['red']}âš ï¸{FIRE_COLORS['reset']}",
    "menu": f"{FIRE_COLORS['blue']}ğŸ“‹{FIRE_COLORS['reset']}"
}

FIRE_SEPARATOR = f"{FIRE_COLORS['red']}-{FIRE_COLORS['orange']}-{FIRE_COLORS['yellow']}-" * 10

# å·¥å…·åŸºç¡€ä¿¡æ¯
TOOL_NAME = "URLå¨èƒæƒ…æŠ¥æ‰«æç³»ç»Ÿï¼ˆWindowså…¼å®¹ç‰ˆï¼‰"
AUTHOR = "p1r07"
VERSION = "7.3.0"
MODIFY_TIME = "2024/06/02 10:30"

# è·¯å¾„é…ç½®ï¼ˆå·¥å…·åŒç›®å½•ï¼‰
å½“å‰ç›®å½• = os.path.dirname(os.path.abspath(__file__))
CSV_OUTPUT_DIR = os.path.join(å½“å‰ç›®å½•, "scan_results")
HISTORY_DIR = os.path.join(å½“å‰ç›®å½•, "scan_history")
CACHE_DIR = os.path.join(å½“å‰ç›®å½•, "cache")
for dir_path in [CSV_OUTPUT_DIR, HISTORY_DIR, CACHE_DIR]:
    os.makedirs(dir_path, exist_ok=True)

# -------------------------- ä¾èµ–æ£€æŸ¥ --------------------------
def æ£€æŸ¥ä¾èµ–():
    """æ£€æŸ¥å¹¶ç¡®ä¿æ‰€æœ‰ä¾èµ–åŒ…å·²å®‰è£…"""
    required_packages = [
        'colorama>=0.4.6',
        'pycryptodome>=3.18.0',
        'tldextract>=3.4.0',
        'aiohttp>=3.8.4'
    ]
    
    missing_packages = []
    for package in required_packages:
        try:
            pkg_resources.require(package)
        except Exception as e:
            missing_packages.append(package.split('>=')[0])
    
    if missing_packages:
        print(f"{Fore.RED}ã€ä¾èµ–ç¼ºå¤±ã€‘éœ€å®‰è£…: {', '.join(missing_packages)}{Style.RESET_ALL}")
        print(f"{Fore.GREEN}å®‰è£…å‘½ä»¤: pip install {' '.join(missing_packages)}{Style.RESET_ALL}")
        sys.exit(1)

# é¢„å…ˆæ‰§è¡Œä¾èµ–æ£€æŸ¥
æ£€æŸ¥ä¾èµ–()

# -------------------------- å³ä¾§æ‰“å°ç®¡ç†å™¨ï¼ˆWindowså…¼å®¹ï¼‰ --------------------------
class å³ä¾§æ‰“å°ç®¡ç†å™¨:
    """æ§åˆ¶Pythonè§£é‡Šå™¨å†…å³ä¾§è¾“å‡ºï¼Œå·¦ä¾§ä¿ç•™å‘½ä»¤äº¤äº’ï¼ˆWindowså…¼å®¹ï¼‰"""
    def __init__(self, split_ratio=0.4):
        """
        Args:
            split_ratio: å·¦ä¾§äº¤äº’åŒºå æ¯”ï¼ˆ0.3~0.5ä¸ºå®œï¼‰
        """
        self.split_ratio = split_ratio
        self.terminal_width = self._get_terminal_width()
        self.left_width = int(self.terminal_width * split_ratio)
        self.right_width = self.terminal_width - self.left_width - 1  # å‡1é¿å…æ¢è¡Œ
        self.right_buffer = []
        
        # åˆå§‹åŒ–æ—¥å¿—é‡å®šå‘ï¼ˆå°†loggingè¾“å‡ºåˆ°å³ä¾§ï¼‰
        self._init_logging_redirect()
        
    def _get_terminal_width(self):
        """è·å–ç»ˆç«¯å®½åº¦ï¼ˆWindowsä¸“ç”¨å®ç°ï¼‰"""
        try:
            if sys.platform.startswith('win'):
                # Windowsç»ˆç«¯å®½åº¦è·å–
                h = ctypes.windll.kernel32.GetStdHandle(-12)
                csbi = ctypes.create_string_buffer(22)
                ctypes.windll.kernel32.GetConsoleScreenBufferInfo(h, csbi)
                return ctypes.c_int32.from_buffer(csbi, 18).value
            else:
                # éWindowsé»˜è®¤å®½åº¦
                return 120
        except:
            return 120  # é»˜è®¤å®½åº¦
    
   
    def _init_logging_redirect(self):
        """é‡å®šå‘loggingè¾“å‡ºåˆ°å³ä¾§åŒºåŸŸ"""
        class å³ä¾§æ—¥å¿—å¤„ç†å™¨(logging.Handler):
            def __init__(self, parent):
                super().__init__()
                self.parent = parent
            
            def emit(self, record):
                msg = self.format(record)
                self.parent.print_to_right(msg)
        
        # é…ç½®æ—¥å¿—æ ¼å¼
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        logger.handlers = []  # æ¸…ç©ºé»˜è®¤å¤„ç†å™¨
        
        # æ·»åŠ å³ä¾§æ—¥å¿—å¤„ç†å™¨
        right_handler = å³ä¾§æ—¥å¿—å¤„ç†å™¨(self)
        formatter = logging.Formatter(
            f"{FIRE_COLORS['orange']}[%(asctime)s]{FIRE_COLORS['reset']} %(message)s",
            datefmt="%H:%M:%S"
        )
        right_handler.setFormatter(formatter)
        logger.addHandler(right_handler)
    
    def clear_right(self):
        """æ¸…ç©ºå³ä¾§åŒºåŸŸ"""
        # ANSIè½¬ä¹‰åºåˆ—ï¼šç§»åŠ¨åˆ°å³ä¾§èµ·å§‹ä½ç½® + æ¸…ç©ºè¡Œ + å‘ä¸‹æ¸…ç©º
        clear_cmd = f"\033[{self.left_width+1}G\033[K"
        for _ in range(20):  # æ¸…ç©º20è¡Œï¼ˆå¯æ ¹æ®éœ€æ±‚è°ƒæ•´ï¼‰
            print(clear_cmd, end='', flush=True)
            print("\033[1B", end='', flush=True)  # ä¸‹ç§»ä¸€è¡Œ
        # å›åˆ°å³ä¾§é¡¶éƒ¨
        print(f"\033[{20}A\033[{self.left_width+1}G", end='', flush=True)
    
    def print_to_right(self, msg):
        """æ‰“å°å†…å®¹åˆ°å³ä¾§åŒºåŸŸ"""
        # ç¡®ä¿æ¶ˆæ¯ä¸è¶…è¿‡å³ä¾§å®½åº¦
        if len(msg) > self.right_width:
            # åˆ†å‰²é•¿æ¶ˆæ¯ï¼ˆæŒ‰å³ä¾§å®½åº¦æ¢è¡Œï¼‰
            for i in range(0, len(msg), self.right_width):
                sub_msg = msg[i:i+self.right_width]
                self._print_single_line(sub_msg)
        else:
            self._print_single_line(msg)
    
    def _print_single_line(self, line):
        """æ‰“å°å•è¡Œåˆ°å³ä¾§"""
        # ANSIè½¬ä¹‰åºåˆ—ï¼šç§»åŠ¨åˆ°å³ä¾§èµ·å§‹åˆ— + æ‰“å°å†…å®¹ + æ¸…ç©ºå½“å‰è¡Œå‰©ä½™éƒ¨åˆ†
        print(f"\033[{self.left_width+1}G{line}\033[K", end='\n', flush=True)
        # å›åˆ°å·¦ä¾§å½“å‰è¡Œï¼ˆç¡®ä¿å‘½ä»¤è¾“å…¥ä¸å—å½±å“ï¼‰
        print(f"\033[{self.left_width+1}G\033[{len(line)}D\033[{self.left_width}D", end='', flush=True)
    
    def reset_terminal(self):
        """é‡ç½®ç»ˆç«¯å¸ƒå±€ï¼ˆç¨‹åºé€€å‡ºæ—¶è°ƒç”¨ï¼‰"""
        print("\033[0m\033[H\033[J", end='', flush=True)  # é‡ç½®é¢œè‰² + æ¸…ç©ºå±å¹•
    
    def ç­‰å¾…ç”¨æˆ·æŒ‰é”®(self):
        """Windowså…¼å®¹çš„ç­‰å¾…æŒ‰é”®ï¼ˆç§»é™¤ttyä¾èµ–ï¼‰"""
        print(f"\n{FIRE_ICONS['info']} æŒ‰ä»»æ„é”®ç»§ç»­...", end='', flush=True)
        if sys.platform.startswith('win'):
            msvcrt.getch()  # WindowsæŒ‰é”®è·å–
        else:
            input()  # éWindowså…¼å®¹æ–¹å¼
        print("\r" + " " * 30 + "\r", end='', flush=True)

# -------------------------- é…ç½®ç®¡ç†ï¼ˆå«é˜¿é‡Œäº‘åŒå¯†é’¥ï¼‰ --------------------------
class é…ç½®ç®¡ç†å™¨:
    """é…ç½®ç®¡ç†ï¼ˆæ”¯æŒé˜¿é‡Œäº‘AccessKeyId/AccessKeySecretã€APIå¯†é’¥ã€ç³»ç»Ÿè®¾ç½®ï¼‰"""
    def __init__(self):
        # é…ç½®æ–‡ä»¶è·¯å¾„ï¼ˆè·¨å¹³å°ï¼‰
        if sys.platform.startswith('win'):
            self.config_dir = os.path.join(os.environ['APPDATA'], 'url_scanner')
        else:
            self.config_dir = os.path.expanduser('~/.url_scanner')
        os.makedirs(self.config_dir, exist_ok=True)
        self.config_path = os.path.join(self.config_dir, 'config.ini')
        self.config = configparser.ConfigParser()
        
        # åŠ è½½æˆ–åˆå§‹åŒ–é…ç½®
        if os.path.exists(self.config_path):
            self.config.read(self.config_path, encoding='utf-8')
        else:
            self._init_default_config()
    
    def _init_default_config(self):
        """åˆå§‹åŒ–é»˜è®¤é…ç½®"""
        # é˜¿é‡Œäº‘å¤‡æ¡ˆAPIï¼ˆæŒ‰å®˜æ–¹æ–‡æ¡£éœ€åŒå¯†é’¥ï¼‰
        self.config['ALIYUN_BEI_AN'] = {
            'AccessKeyId': '',
            'AccessKeySecret': '',
            'RegionId': 'cn-hangzhou',  # å®˜æ–¹é»˜è®¤Region
            'ApiVersion': '2018-06-08'   # å®˜æ–¹æœ€æ–°ç‰ˆæœ¬
        }
        
        # å¨èƒæƒ…æŠ¥API
        self.config['THREAT_API'] = {
            'virustotal_key': '',
            'weibu_key': ''
        }
        
        # ç³»ç»Ÿè®¾ç½®
        self.config['SYSTEM'] = {
            'default_workers': '3',
            'timeout': '15',
            'print_delay': '0.05',
            'show_banner': 'True',
            'auto_save_csv': 'True'
        }
        
        # ä¿å­˜é»˜è®¤é…ç½®
        self.save_config()
    
    def save_config(self):
        """ä¿å­˜é…ç½®åˆ°æ–‡ä»¶"""
        try:
            with open(self.config_path, 'w', encoding='utf-8') as f:
                self.config.write(f)
            return True
        except Exception as e:
            logging.error(f"{FIRE_ICONS['error']} ä¿å­˜é…ç½®å¤±è´¥: {str(e)}")
            return False
    
    # -------------------------- é˜¿é‡Œäº‘å¤‡æ¡ˆAPIé…ç½® --------------------------
    def get_aliyun_config(self):
        """è·å–é˜¿é‡Œäº‘å¤‡æ¡ˆAPIé…ç½®ï¼ˆå«åŒå¯†é’¥ï¼‰"""
        if 'ALIYUN_BEI_AN' not in self.config:
            self.config['ALIYUN_BEI_AN'] = {'AccessKeyId': '', 'AccessKeySecret': '', 'RegionId': 'cn-hangzhou'}
        return {
            'AccessKeyId': self.config['ALIYUN_BEI_AN'].get('AccessKeyId', ''),
            'AccessKeySecret': self.config['ALIYUN_BEI_AN'].get('AccessKeySecret', ''),
            'RegionId': self.config['ALIYUN_BEI_AN'].get('RegionId', 'cn-hangzhou'),
            'ApiVersion': self.config['ALIYUN_BEI_AN'].get('ApiVersion', '2018-06-08')
        }
    
    def set_aliyun_config(self, access_key_id, access_key_secret, region_id='cn-hangzhou'):
        """è®¾ç½®é˜¿é‡Œäº‘å¤‡æ¡ˆAPIé…ç½®"""
        if 'ALIYUN_BEI_AN' not in self.config:
            self.config['ALIYUN_BEI_AN'] = {}
        self.config['ALIYUN_BEI_AN']['AccessKeyId'] = access_key_id
        self.config['ALIYUN_BEI_AN']['AccessKeySecret'] = access_key_secret
        self.config['ALIYUN_BEI_AN']['RegionId'] = region_id
        return self.save_config()
    
    # -------------------------- å¨èƒæƒ…æŠ¥APIé…ç½® --------------------------
    def get_threat_api_key(self, api_name):
        """è·å–å¨èƒæƒ…æŠ¥APIå¯†é’¥ï¼ˆvirustotal/weibuï¼‰"""
        if 'THREAT_API' not in self.config:
            return ''
        return self.config['THREAT_API'].get(f'{api_name}_key', '')
    
    def set_threat_api_key(self, api_name, api_key):
        """è®¾ç½®å¨èƒæƒ…æŠ¥APIå¯†é’¥"""
        if 'THREAT_API' not in self.config:
            self.config['THREAT_API'] = {}
        self.config['THREAT_API'][f'{api_name}_key'] = api_key
        return self.save_config()
    
    # -------------------------- ç³»ç»Ÿè®¾ç½® --------------------------
    def get_system_setting(self, key, default=''):
        """è·å–ç³»ç»Ÿè®¾ç½®"""
        if 'SYSTEM' not in self.config:
            return default
        return self.config['SYSTEM'].get(key, default)
    
    def set_system_setting(self, key, value):
        """è®¾ç½®ç³»ç»Ÿè®¾ç½®"""
        if 'SYSTEM' not in self.config:
            self.config['SYSTEM'] = {}
        self.config['SYSTEM'][key] = str(value)
        return self.save_config()
    
    def æ˜¾ç¤ºé…ç½®ä¿¡æ¯(self):
        """æ˜¾ç¤ºå½“å‰é…ç½®ä¿¡æ¯"""
        print(f"\n{FIRE_SEPARATOR}")
        print(f"{FIRE_ICONS['info']} {FIRE_COLORS['blue']}å½“å‰é…ç½®ä¿¡æ¯{FIRE_COLORS['reset']}")
        print(f"{FIRE_SEPARATOR}\n")
        
        # é˜¿é‡Œäº‘é…ç½®
        aliyun_cfg = self.get_aliyun_config()
        print(f"{FIRE_COLORS['yellow']}é˜¿é‡Œäº‘å¤‡æ¡ˆAPIé…ç½®:{FIRE_COLORS['reset']}")
        print(f"  AccessKeyId: {'å·²é…ç½®' if aliyun_cfg['AccessKeyId'] else 'æœªé…ç½®'}")
        print(f"  AccessKeySecret: {'å·²é…ç½®' if aliyun_cfg['AccessKeySecret'] else 'æœªé…ç½®'}")
        print(f"  RegionId: {aliyun_cfg['RegionId']}")
        print(f"  ApiVersion: {aliyun_cfg['ApiVersion']}\n")
        
        # å¨èƒæƒ…æŠ¥é…ç½®
        print(f"{FIRE_COLORS['yellow']}å¨èƒæƒ…æŠ¥APIé…ç½®:{FIRE_COLORS['reset']}")
        print(f"  VirusTotal: {'å·²é…ç½®' if self.get_threat_api_key('virustotal') else 'æœªé…ç½®'}")
        print(f"  å¾®æ­¥æƒ…æŠ¥: {'å·²é…ç½®' if self.get_threat_api_key('weibu') else 'æœªé…ç½®'}\n")
        
        # ç³»ç»Ÿè®¾ç½®
        print(f"{FIRE_COLORS['yellow']}ç³»ç»Ÿè®¾ç½®:{FIRE_COLORS['reset']}")
        print(f"  é»˜è®¤å·¥ä½œçº¿ç¨‹æ•°: {self.get_system_setting('default_workers', '3')}")
        print(f"  è¶…æ—¶æ—¶é—´(ç§’): {self.get_system_setting('timeout', '15')}")
        print(f"  æ‰“å°å»¶è¿Ÿ(ç§’): {self.get_system_setting('print_delay', '0.05')}")
        print(f"  æ˜¾ç¤ºBanner: {'æ˜¯' if self.get_system_setting('show_banner') == 'True' else 'å¦'}")
        print(f"  è‡ªåŠ¨ä¿å­˜CSV: {'æ˜¯' if self.get_system_setting('auto_save_csv') == 'True' else 'å¦'}\n")

# -------------------------- é˜¿é‡Œäº‘APIç­¾åå·¥å…·ï¼ˆæŒ‰å®˜æ–¹æ–‡æ¡£å®ç°ï¼‰ --------------------------
class é˜¿é‡Œäº‘ç­¾åå·¥å…·:
    """é˜¿é‡Œäº‘APIç­¾åç”Ÿæˆå™¨ï¼ˆéµå¾ªå®˜æ–¹HMAC-SHA1ç­¾åè§„èŒƒï¼‰"""
    @staticmethod
    def generate_signature(params, access_key_secret):
        """
        ç”Ÿæˆé˜¿é‡Œäº‘APIç­¾å
        å‚è€ƒæ–‡æ¡£ï¼šhttps://developer.aliyun.com/article/1670298#section-4
        """
        # 1. æŒ‰å‚æ•°åASCIIæ’åº
        sorted_params = sorted(params.items(), key=lambda x: x[0])
        
        # 2. æ‹¼æ¥å‚æ•°ä¸ºURLç¼–ç æ ¼å¼ï¼ˆéœ€ç¼–ç ç‰¹æ®Šå­—ç¬¦ï¼‰
        query_string = ''
        for key, value in sorted_params:
            query_string += f"&{quote_plus(str(key))}={quote_plus(str(value))}"
        
        # 3. æ‹¼æ¥ç­¾ååŸä¸²ï¼ˆå»é™¤ç¬¬ä¸€ä¸ª&ï¼‰
        sign_string = f"GET&%2F&{quote_plus(query_string[1:])}"
        
        # 4. HMAC-SHA1ç­¾å + Base64ç¼–ç 
        hmac_obj = hmac.new(
            f"{access_key_secret}&".encode('utf-8'),  # å¯†é’¥éœ€åŠ &åç¼€
            sign_string.encode('utf-8'),
            hashlib.sha1
        )
        signature = base64.b64encode(hmac_obj.digest()).decode('utf-8')
        return signature
    
    @staticmethod
    def build_request_url(params, access_key_secret, domain='beian.aliyuncs.com'):
        """æ„å»ºå®Œæ•´çš„é˜¿é‡Œäº‘APIè¯·æ±‚URLï¼ˆå«ç­¾åï¼‰"""
        # 1. æ·»åŠ å…¬å…±å‚æ•°ï¼ˆå®˜æ–¹å¿…ä¼ ï¼‰
        public_params = {
            'Format': 'JSON',
            'Version': params.pop('ApiVersion', '2018-06-08'),
            'AccessKeyId': params.pop('AccessKeyId'),
            'SignatureMethod': 'HMAC-SHA1',
            'Timestamp': datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'),
            'SignatureVersion': '1.0',
            'SignatureNonce': str(random.randint(100000, 999999))  # éšæœºæ•°é˜²é‡æ”¾
        }
        
        # 2. åˆå¹¶å…¬å…±å‚æ•°ä¸ä¸šåŠ¡å‚æ•°
        all_params = {**public_params, **params}
        
        # 3. ç”Ÿæˆç­¾å
        signature = é˜¿é‡Œäº‘ç­¾åå·¥å…·.generate_signature(all_params, access_key_secret)
        all_params['Signature'] = signature
        
        # 4. æ„å»ºURL
        query_string = urlencode(all_params)
        return f"https://{domain}?{query_string}"

# -------------------------- å†å²æ•°æ®ç®¡ç† --------------------------
class å†å²æ•°æ®ç®¡ç†å™¨:
    """å†å²æ‰«æè®°å½•ç®¡ç†ï¼ˆä¿å­˜/æŸ¥è¯¢/åˆ é™¤ï¼‰"""
    def __init__(self):
        self.history_dir = HISTORY_DIR
    
    def save_history(self, results, scan_type='single', target='url'):
        """ä¿å­˜æ‰«æç»“æœåˆ°å†å²"""
        timestamp = time.strftime('%Y%m%d_%H%M%S')
        history_id = f"scan_{timestamp}"
        history_path = os.path.join(self.history_dir, f"{history_id}.json")
        
        try:
            with open(history_path, 'w', encoding='utf-8') as f:
                json.dump({
                    'history_id': history_id,
                    'timestamp': timestamp,
                    'scan_type': scan_type,
                    'target': target,
                    'result_count': len(results),
                    'results': results
                }, f, ensure_ascii=False, indent=2)
            
            # æ›´æ–°ç´¢å¼•
            self._update_index(history_id, timestamp, scan_type, target, len(results))
            logging.info(f"{FIRE_ICONS['flame']} å†å²è®°å½•ä¿å­˜æˆåŠŸï¼ˆID: {history_id}ï¼‰")
            return history_id
        except Exception as e:
            logging.error(f"{FIRE_ICONS['error']} ä¿å­˜å†å²è®°å½•å¤±è´¥: {str(e)}")
            return None
    
    def _update_index(self, history_id, timestamp, scan_type, target, count):
        """æ›´æ–°å†å²ç´¢å¼•"""
        index_path = os.path.join(self.history_dir, 'history_index.json')
        index = []
        
        # åŠ è½½ç°æœ‰ç´¢å¼•
        if os.path.exists(index_path):
            with open(index_path, 'r', encoding='utf-8') as f:
                index = json.load(f)
        
        # æ·»åŠ æ–°è®°å½•ï¼ˆæœ€æ–°åœ¨å‰ï¼‰
        index.insert(0, {
            'history_id': history_id,
            'timestamp': timestamp,
            'scan_type': scan_type,
            'target': target[:20] + '...' if len(target) > 20 else target,
            'result_count': count
        })
        
        # é™åˆ¶ç´¢å¼•æ•°é‡ï¼ˆæœ€å¤š100æ¡ï¼‰
        if len(index) > 100:
            index = index[:100]
        
        # ä¿å­˜ç´¢å¼•
        with open(index_path, 'w', encoding='utf-8') as f:
            json.dump(index, f, ensure_ascii=False, indent=2)
    
    def get_history_list(self, limit=10):
        """è·å–å†å²è®°å½•åˆ—è¡¨"""
        index_path = os.path.join(self.history_dir, 'history_index.json')
        if not os.path.exists(index_path):
            return []
        
        with open(index_path, 'r', encoding='utf-8') as f:
            index = json.load(f)
        return index[:limit]
    
    def get_history_detail(self, history_id):
        """è·å–å†å²è®°å½•è¯¦æƒ…"""
        history_path = os.path.join(self.history_dir, f"{history_id}.json")
        if not os.path.exists(history_path):
            logging.warning(f"{FIRE_ICONS['warning']} å†å²è®°å½•ä¸å­˜åœ¨ï¼ˆID: {history_id}ï¼‰")
            return None
        
        try:
            with open(history_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            logging.error(f"{FIRE_ICONS['error']} è¯»å–å†å²è®°å½•å¤±è´¥: {str(e)}")
            return None
    
    def æ˜¾ç¤ºå†å²åˆ—è¡¨(self):
        """æ˜¾ç¤ºå†å²è®°å½•åˆ—è¡¨"""
        history_list = self.get_history_list()
        
        if not history_list:
            print(f"\n{FIRE_ICONS['info']} æ²¡æœ‰å†å²æ‰«æè®°å½•")
            return False
            
        print(f"\n{FIRE_SEPARATOR}")
        print(f"{FIRE_ICONS['flame']} {FIRE_COLORS['purple']}å†å²æ‰«æè®°å½•{FIRE_COLORS['reset']}")
        print(f"{FIRE_SEPARATOR}\n")
        
        print(f"  {FIRE_COLORS['yellow']}ç¼–å· | æ‰«ææ—¶é—´ | æ‰«æç±»å‹ | ç›®æ ‡ | ç»“æœæ•°é‡{FIRE_COLORS['reset']}")
        print(f"  {FIRE_COLORS['orange']}{'-'*70}{FIRE_COLORS['reset']}")
        
        for i, record in enumerate(history_list, 1):
            # æ ¼å¼åŒ–æ—¶é—´
            try:
                dt = datetime.strptime(record['timestamp'], '%Y%m%d_%H%M%S')
                formatted_time = dt.strftime('%Y-%m-%d %H:%M')
            except:
                formatted_time = record['timestamp']
                
            # æ˜¾ç¤ºä¿¡æ¯
            print(f"  {i:2d}   {formatted_time}  {record['scan_type']:8s}  {record['target']:20s}  {record['result_count']}")
        
        print(f"\n{FIRE_ICONS['info']} è¾“å…¥ç¼–å·æŸ¥çœ‹è¯¦æƒ…ï¼Œ0è¿”å›ä¸»èœå•")
        return True

# -------------------------- ç¼“å­˜ç®¡ç† --------------------------
class ç¼“å­˜ç®¡ç†å™¨:
    """ç¼“å­˜ç®¡ç†ï¼ˆICP/IP/å¨èƒæƒ…æŠ¥ï¼‰"""
    def __init__(self):
        self.cache_dir = CACHE_DIR
        self.cache_expire = {
            'icp': 86400,    # 1å¤©
            'ip': 3600,      # 1å°æ—¶
            'threat': 3600   # 1å°æ—¶
        }
    
    def get_cache(self, cache_type, key):
        """è·å–ç¼“å­˜ï¼ˆå¸¦è¿‡æœŸæ£€æŸ¥ï¼‰"""
        cache_path = os.path.join(self.cache_dir, f"{cache_type}_cache.json")
        if not os.path.exists(cache_path):
            return None
        
        try:
            with open(cache_path, 'r', encoding='utf-8') as f:
                cache = json.load(f)
            
            # æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨ä¸”æœªè¿‡æœŸ
            if key in cache:
                data = cache[key]
                if time.time() - data['timestamp'] < self.cache_expire[cache_type]:
                    return data['value']
                else:
                    # è¿‡æœŸç¼“å­˜æ¸…ç†
                    del cache[key]
                    self._save_cache(cache_type, cache)
            return None
        except Exception as e:
            logging.warning(f"{FIRE_ICONS['warning']} è¯»å–{cache_type}ç¼“å­˜å¤±è´¥: {str(e)}")
            return None
    
    def set_cache(self, cache_type, key, value):
        """è®¾ç½®ç¼“å­˜"""
        cache_path = os.path.join(self.cache_dir, f"{cache_type}_cache.json")
        cache = {}
        
        # åŠ è½½ç°æœ‰ç¼“å­˜
        if os.path.exists(cache_path):
            with open(cache_path, 'r', encoding='utf-8') as f:
                cache = json.load(f)
        
        # æ›´æ–°ç¼“å­˜
        cache[key] = {
            'timestamp': time.time(),
            'value': value
        }
        
        # ä¿å­˜ç¼“å­˜
        self._save_cache(cache_type, cache)
    
    def _save_cache(self, cache_type, cache_data):
        """ä¿å­˜ç¼“å­˜åˆ°æ–‡ä»¶"""
        cache_path = os.path.join(self.cache_dir, f"{cache_type}_cache.json")
        try:
            with open(cache_path, 'w', encoding='utf-8') as f:
                json.dump(cache_data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logging.error(f"{FIRE_ICONS['error']} ä¿å­˜{cache_type}ç¼“å­˜å¤±è´¥: {str(e)}")
    
    def clear_cache(self, cache_type=None):
        """æ¸…é™¤ç¼“å­˜ï¼ˆæŒ‡å®šç±»å‹æˆ–å…¨éƒ¨ï¼‰"""
        if cache_type:
            cache_path = os.path.join(self.cache_dir, f"{cache_type}_cache.json")
            if os.path.exists(cache_path):
                os.remove(cache_path)
            logging.info(f"{FIRE_ICONS['info']} {cache_type}ç¼“å­˜å·²æ¸…é™¤")
            return True
        
        # æ¸…é™¤å…¨éƒ¨ç¼“å­˜
        for file_name in os.listdir(self.cache_dir):
            if file_name.endswith('_cache.json'):
                os.remove(os.path.join(self.cache_dir, file_name))
        logging.info(f"{FIRE_ICONS['info']} å…¨éƒ¨ç¼“å­˜å·²æ¸…é™¤")
        return True

# -------------------------- å¨èƒæƒ…æŠ¥åˆ†æå™¨ --------------------------
class å¨èƒæƒ…æŠ¥åˆ†æå™¨:
    """é›†æˆVirusTotalã€å¾®æ­¥æƒ…æŠ¥çš„å¨èƒåˆ†æ"""
    def __init__(self, config_manager, cache_manager):
        self.config = config_manager
        self.cache = cache_manager
        self.session = None
        
        # åŠ è½½APIå¯†é’¥
        self.vt_key = self.config.get_threat_api_key('virustotal')
        self.weibu_key = self.config.get_threat_api_key('weibu')
    
    async def init_session(self):
        """åˆå§‹åŒ–aiohttpä¼šè¯"""
        if not self.session:
            self.session = aiohttp.ClientSession()
        return self.session
    
    async def analyze_ip(self, ip):
        """åˆ†æIPå¨èƒæƒ…æŠ¥"""
        # å…ˆæŸ¥ç¼“å­˜
        cached = self.cache.get_cache('threat', f'ip_{ip}')
        if cached:
            cached['source'] = 'cache'
            return cached
        
        # å¤šæºåˆ†æ
        results = []
        if self.vt_key:
            vt_result = await self._vt_analyze_ip(ip)
            if vt_result:
                results.append(('virustotal', vt_result))
        
        if self.weibu_key:
            weibu_result = await self._weibu_analyze_ip(ip)
            if weibu_result:
                results.append(('weibu', weibu_result))
        
        # èåˆç»“æœ
        if not results:
            result = {
                'ip': ip,
                'risk_level': 'none',
                'risk_label': f"{FIRE_COLORS['gold']}æ— é£é™©{FIRE_COLORS['reset']}",
                'detection_rate': 0,
                'tags': [],
                'source': 'none'
            }
        else:
            result = self._merge_results(results, ip, is_ip=True)
        
        # ç¼“å­˜ç»“æœ
        self.cache.set_cache('threat', f'ip_{ip}', result)
        return result
    
    async def _vt_analyze_ip(self, ip):
        """VirusTotal IPåˆ†æ"""
        try:
            session = await self.init_session()
            url = f"https://www.virustotal.com/api/v3/ip_addresses/{ip}"
            headers = {'x-apikey': self.vt_key}
            
            async with session.get(url, headers=headers, timeout=10) as resp:
                if resp.status != 200:
                    return None
                
                data = await resp.json()
                attrs = data['data']['attributes']
                stats = attrs['last_analysis_stats']
                
                return {
                    'risk': stats['malicious'] > 0,
                    'detection_rate': (stats['malicious'] / stats['total']) * 100 if stats['total'] > 0 else 0,
                    'tags': attrs.get('tags', []),
                    'country': attrs.get('country', 'æœªçŸ¥')
                }
        except Exception as e:
            logging.warning(f"{FIRE_ICONS['warning']} VT IPåˆ†æå¤±è´¥: {str(e)}")
            return None
    
    async def _weibu_analyze_ip(self, ip):
        """å¾®æ­¥æƒ…æŠ¥IPåˆ†æ"""
        try:
            session = await self.init_session()
            url = f"https://api.threatbook.cn/v3/ip/query"
            params = {'apikey': self.weibu_key, 'resource': ip}
            
            async with session.get(url, params=params, timeout=10) as resp:
                if resp.status != 200:
                    return None
                
                data = await resp.json()
                if data['response_code'] != 0:
                    return None
                
                return {
                    'risk': data['data']['judgment'] == 'malicious',
                    'detection_rate': data['data'].get('confidence', 0),
                    'tags': data['data'].get('tags', []),
                    'country': data['data']['location'].get('country', 'æœªçŸ¥')
                }
        except Exception as e:
            logging.warning(f"{FIRE_ICONS['warning']} å¾®æ­¥IPåˆ†æå¤±è´¥: {str(e)}")
            return None
    
    async def analyze_url(self, url):
        """åˆ†æURLå¨èƒæƒ…æŠ¥"""
        # å…ˆæŸ¥ç¼“å­˜
        cached = self.cache.get_cache('threat', f'url_{url}')
        if cached:
            cached['source'] = 'cache'
            return cached
        
        # å¤šæºåˆ†æ
        results = []
        if self.vt_key:
            vt_result = await self._vt_analyze_url(url)
            if vt_result:
                results.append(('virustotal', vt_result))
        
        if self.weibu_key:
            weibu_result = await self._weibu_analyze_url(url)
            if weibu_result:
                results.append(('weibu', weibu_result))
        
        # èåˆç»“æœ
        if not results:
            result = {
                'url': url,
                'risk_level': 'none',
                'risk_label': f"{FIRE_COLORS['gold']}æ— é£é™©{FIRE_COLORS['reset']}",
                'detection_rate': 0,
                'tags': [],
                'source': 'none'
            }
        else:
            result = self._merge_results(results, url, is_ip=False)
        
        # ç¼“å­˜ç»“æœ
        self.cache.set_cache('threat', f'url_{url}', result)
        return result
    
    async def _vt_analyze_url(self, url):
        """VirusTotal URLåˆ†æ"""
        try:
            session = await self.init_session()
            # VT URLåˆ†æéœ€å…ˆç¼–ç URL
            url_id = base64.urlsafe_b64encode(url.encode()).decode().strip('=')
            url = f"https://www.virustotal.com/api/v3/urls/{url_id}"
            headers = {'x-apikey': self.vt_key}
            
            async with session.get(url, headers=headers, timeout=10) as resp:
                if resp.status != 200:
                    return None
                
                data = await resp.json()
                attrs = data['data']['attributes']
                stats = attrs['last_analysis_stats']
                
                return {
                    'risk': stats['malicious'] > 0,
                    'detection_rate': (stats['malicious'] / stats['total']) * 100 if stats['total'] > 0 else 0,
                    'tags': attrs.get('tags', []),
                    'reputation': attrs.get('reputation', 0)
                }
        except Exception as e:
            logging.warning(f"{FIRE_ICONS['warning']} VT URLåˆ†æå¤±è´¥: {str(e)}")
            return None
    
    async def _weibu_analyze_url(self, url):
        """å¾®æ­¥æƒ…æŠ¥URLåˆ†æ"""
        try:
            session = await self.init_session()
            url = f"https://api.threatbook.cn/v3/url/query"
            params = {'apikey': self.weibu_key, 'resource': url}
            
            async with session.get(url, params=params, timeout=10) as resp:
                if resp.status != 200:
                    return None
                
                data = await resp.json()
                if data['response_code'] != 0:
                    return None
                
                return {
                    'risk': data['data']['judgment'] == 'malicious',
                    'detection_rate': data['data'].get('confidence', 0),
                    'tags': data['data'].get('tags', []),
                    'category': data['data'].get('category', 'æœªçŸ¥')
                }
        except Exception as e:
            logging.warning(f"{FIRE_ICONS['warning']} å¾®æ­¥URLåˆ†æå¤±è´¥: {str(e)}")
            return None
    
    def _merge_results(self, results, target, is_ip=True):
        """èåˆå¤šæºå¨èƒæƒ…æŠ¥ç»“æœ"""
        merged = {
            'risk_level': 'none',
            'risk_label': f"{FIRE_COLORS['gold']}æ— é£é™©{FIRE_COLORS['reset']}",
            'detection_rate': 0,
            'tags': [],
            'sources': [r[0] for r in results],
            'detail': results
        }
        
        if is_ip:
            merged['ip'] = target
        else:
            merged['url'] = target
        
        # è®¡ç®—å¹³å‡æ£€æµ‹ç‡
        total_rate = sum(r[1]['detection_rate'] for r in results)
        merged['detection_rate'] = round(total_rate / len(results), 2)
        
        # åˆå¹¶æ ‡ç­¾
        all_tags = []
        for _, result in results:
            all_tags.extend(result['tags'])
        merged['tags'] = list(set(all_tags))  # å»é‡
        
        # åˆ¤æ–­é£é™©çº§åˆ«
        if merged['detection_rate'] > 70:
            merged['risk_level'] = 'high'
            merged['risk_label'] = f"{FIRE_COLORS['red']}é«˜é£é™©{FIRE_COLORS['reset']}"
        elif merged['detection_rate'] > 30:
            merged['risk_level'] = 'medium'
            merged['risk_label'] = f"{FIRE_COLORS['orange']}ä¸­é£é™©{FIRE_COLORS['reset']}"
        elif merged['detection_rate'] > 0:
            merged['risk_level'] = 'low'
            merged['risk_label'] = f"{FIRE_COLORS['yellow']}ä½é£é™©{FIRE_COLORS['reset']}"
        
        return merged
    
    async def close(self):
        """å…³é—­ä¼šè¯"""
        if self.session:
            await self.session.close()

# -------------------------- ICPå¤‡æ¡ˆæŸ¥è¯¢å™¨ï¼ˆé˜¿é‡Œäº‘APIä¼˜åŒ–ç‰ˆï¼‰ --------------------------
class ICPå¤‡æ¡ˆæŸ¥è¯¢å™¨:
    """å¤šæºICPå¤‡æ¡ˆæŸ¥è¯¢ï¼ˆå«é˜¿é‡Œäº‘å®˜æ–¹APIã€å·¥ä¿¡éƒ¨æ¥å£ï¼‰"""
    def __init__(self, config_manager, cache_manager):
        self.config = config_manager
        self.cache = cache_manager
        self.session = None
        
        # åŠ è½½é˜¿é‡Œäº‘é…ç½®
        self.aliyun_config = self.config.get_aliyun_config()
        self.aliyun_enabled = bool(self.aliyun_config['AccessKeyId'] and self.aliyun_config['AccessKeySecret'])
        
        # å·¥ä¿¡éƒ¨æ¥å£é…ç½®
        self.miit_base_url = "https://hlwicpfwc.miit.gov.cn/icpproject_query/api"
        self.miit_headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
            'Origin': 'https://beian.miit.gov.cn',
            'Referer': 'https://beian.miit.gov.cn/',
            'Content-Type': 'application/json;charset=UTF-8'
        }
        self.miit_initialized = False
    
    async def init_session(self):
        """åˆå§‹åŒ–ä¼šè¯"""
        if not self.session:
            self.session = aiohttp.ClientSession()
        return self.session
    
    # -------------------------- é˜¿é‡Œäº‘å¤‡æ¡ˆæŸ¥è¯¢ï¼ˆæŒ‰å®˜æ–¹æ–‡æ¡£å®ç°ï¼‰ --------------------------
    async def query_aliyun_icp(self, domain):
        """
        é˜¿é‡Œäº‘å¤‡æ¡ˆæŸ¥è¯¢ï¼ˆå®˜æ–¹APIï¼‰
        æ¥å£æ–‡æ¡£ï¼šhttps://developer.aliyun.com/article/1670298#section-3
        """
        if not self.aliyun_enabled:
            logging.warning(f"{FIRE_ICONS['warning']} é˜¿é‡Œäº‘å¤‡æ¡ˆAPIæœªé…ç½®ï¼ˆéœ€AccessKeyIdå’ŒAccessKeySecretï¼‰")
            return None
        
        # å…ˆæŸ¥ç¼“å­˜
        cached = self.cache.get_cache('icp', f'aliyun_{domain}')
        if cached:
            cached['source'] = 'aliyun_cache'
            return cached
        
        try:
            session = await self.init_session()
            
            # 1. æ„å»ºä¸šåŠ¡å‚æ•°ï¼ˆå®˜æ–¹å¿…ä¼ å‚æ•°ï¼‰
            params = {
                'Action': 'QueryDomainBeianInfo',  # å®˜æ–¹æ¥å£åç§°
                'DomainName': domain,             # å¾…æŸ¥è¯¢åŸŸå
                'AccessKeyId': self.aliyun_config['AccessKeyId'],
                'ApiVersion': self.aliyun_config['ApiVersion'],
                'RegionId': self.aliyun_config['RegionId']
            }
            
            # 2. ç”Ÿæˆç­¾åURL
            request_url = é˜¿é‡Œäº‘ç­¾åå·¥å…·.build_request_url(
                params, 
                self.aliyun_config['AccessKeySecret']
            )
            
            # 3. å‘é€è¯·æ±‚
            async with session.get(request_url, timeout=15) as resp:
                if resp.status != 200:
                    logging.error(f"{FIRE_ICONS['error']} é˜¿é‡Œäº‘APIè¯·æ±‚å¤±è´¥ï¼ˆçŠ¶æ€ç : {resp.status}ï¼‰")
                    return None
                
                data = await resp.json()
                return self._parse_aliyun_response(data, domain)
        
        except Exception as e:
            logging.error(f"{FIRE_ICONS['error']} é˜¿é‡Œäº‘å¤‡æ¡ˆæŸ¥è¯¢å¤±è´¥: {str(e)}")
            return None
    
    def _parse_aliyun_response(self, data, domain):
        """è§£æé˜¿é‡Œäº‘å¤‡æ¡ˆAPIå“åº”ï¼ˆæŒ‰å®˜æ–¹è¿”å›æ ¼å¼ï¼‰"""
        # å®˜æ–¹æˆåŠŸå“åº”æ ¼å¼ï¼š{"RequestId":"xxx","DomainBeianInfo":{"..."},"Success":true}
        if not data.get('Success'):
            error_msg = data.get('Message', 'æœªçŸ¥é”™è¯¯')
            error_code = data.get('Code', 'æœªçŸ¥é”™è¯¯ç ')
            logging.warning(f"{FIRE_ICONS['warning']} é˜¿é‡Œäº‘å¤‡æ¡ˆæŸ¥è¯¢æ— ç»“æœ: {error_msg}ï¼ˆé”™è¯¯ç : {error_code}ï¼‰")
            
            # æ˜ç¡®æ ‡æ³¨æœªå¤‡æ¡ˆçŠ¶æ€
            result = {
                'domain': domain,
                'has_icp': False,
                'å¤‡æ¡ˆçŠ¶æ€': 'æœªå¤‡æ¡ˆ',
                'source': 'aliyun',
                'message': f"{error_msg}ï¼ˆé”™è¯¯ç : {error_code}ï¼‰"
            }
            self.cache.set_cache('icp', f'aliyun_{domain}', result)
            return result
        
        # è§£æå¤‡æ¡ˆä¿¡æ¯ï¼ˆå®˜æ–¹è¿”å›å­—æ®µï¼‰
        beian_info = data.get('DomainBeianInfo', {})
        result = {
            'domain': domain,
            'has_icp': True,
            'å¤‡æ¡ˆçŠ¶æ€': 'å·²å¤‡æ¡ˆ',
            'source': 'aliyun',
            'license': beian_info.get('ServiceLicense', 'æœªçŸ¥'),  # å¤‡æ¡ˆè®¸å¯è¯å·
            'unit': beian_info.get('UnitName', 'æœªçŸ¥'),          # ä¸»åŠå•ä½åç§°
            'unit_type': beian_info.get('UnitType', 'æœªçŸ¥'),    # å•ä½ç±»å‹ï¼ˆä¼ä¸š/ä¸ªäººï¼‰
            'website_name': beian_info.get('WebsiteName', 'æœªçŸ¥'),  # ç½‘ç«™åç§°
            'website_type': beian_info.get('WebsiteType', 'æœªçŸ¥'),  # ç½‘ç«™ç±»å‹
            'update_time': beian_info.get('UpdateTime', time.strftime('%Y-%m-%d %H:%M:%S')),  # æœ€åæ›´æ–°æ—¶é—´
            'service_type': beian_info.get('ServiceType', 'æœªçŸ¥'),  # æœåŠ¡ç±»å‹
            'main_domain': beian_info.get('MainDomain', domain)     # ä¸»åŸŸå
        }
        
        # ç¼“å­˜ç»“æœ
        self.cache.set_cache('icp', f'aliyun_{domain}', result)
        return result
    
    # -------------------------- å·¥ä¿¡éƒ¨å¤‡æ¡ˆæŸ¥è¯¢ --------------------------
    async def query_miit_icp(self, domain):
        """å·¥ä¿¡éƒ¨å¤‡æ¡ˆæŸ¥è¯¢ï¼ˆå¤‡ç”¨æ¥å£ï¼‰"""
        # å…ˆæŸ¥ç¼“å­˜
        cached = self.cache.get_cache('icp', f'miit_{domain}')
        if cached:
            cached['source'] = 'miit_cache'
            return cached
        
        # åˆå§‹åŒ–å·¥ä¿¡éƒ¨ä¼šè¯
        if not self.miit_initialized:
            if not await self._init_miit_session():
                logging.warning(f"{FIRE_ICONS['warning']} å·¥ä¿¡éƒ¨æ¥å£åˆå§‹åŒ–å¤±è´¥ï¼Œå°†è·³è¿‡è¯¥æºæŸ¥è¯¢")
                return None
        
        try:
            session = await self.init_session()
            
            # å¤šæ¡ä»¶æŸ¥è¯¢æé«˜å‡†ç¡®æ€§
            for service_type in [1, 0]:  # 1:ç½‘ç«™, 0:å…¨éƒ¨ç±»å‹
                data = {
                    "pageNum": 1,
                    "pageSize": 20,
                    "unitName": "",
                    "serviceType": service_type,
                    "domainName": domain
                }
                
                async with session.post(
                    f"{self.miit_base_url}/icpAbbreviateInfo/queryByCondition",
                    json=data,
                    headers=self.miit_headers,
                    timeout=15
                ) as resp:
                    if resp.status != 200:
                        continue
                    
                    data = await resp.json()
                    parsed = self._parse_miit_response(data, domain)
                    if parsed:
                        self.cache.set_cache('icp', f'miit_{domain}', parsed)
                        return parsed
            
            # æ— ç»“æœæ—¶è¿”å›æœªå¤‡æ¡ˆ
            result = {
                'domain': domain,
                'has_icp': False,
                'å¤‡æ¡ˆçŠ¶æ€': 'æœªå¤‡æ¡ˆ',
                'source': 'miit',
                'message': 'å·¥ä¿¡éƒ¨æ¥å£æœªæŸ¥è¯¢åˆ°å¤‡æ¡ˆä¿¡æ¯'
            }
            self.cache.set_cache('icp', f'miit_{domain}', result)
            return result
        
        except Exception as e:
            logging.error(f"{FIRE_ICONS['error']} å·¥ä¿¡éƒ¨å¤‡æ¡ˆæŸ¥è¯¢å¤±è´¥: {str(e)}")
            return None
    
    async def _init_miit_session(self):
        """åˆå§‹åŒ–å·¥ä¿¡éƒ¨æ¥å£ä¼šè¯ï¼ˆå¤„ç†Cookieå’ŒTokenï¼‰"""
        try:
            session = await self.init_session()
            
            # 1. è·å–åŸºç¡€Cookie
            async with session.get("https://beian.miit.gov.cn/") as resp:
                cookies = resp.cookies
                cookie_list = []
                for cookie in cookies:
                    cookie_list.append(f"{cookie.name}={cookie.value}")
                    if cookie.name.startswith("__jsluid_s"):
                        self.miit_headers['Cookie'] = "; ".join(cookie_list)
                        break
            
            # 2. è·å–è®¤è¯Token
            timestamp = round(time.time() * 1000)
            auth_key = hashlib.md5(f"testtest{timestamp}".encode()).hexdigest()
            auth_data = {"authKey": auth_key, "timeStamp": timestamp}
            
            async with session.post(
                f"{self.miit_base_url}/auth",
                json=auth_data,
                headers=self.miit_headers
            ) as resp:
                data = await resp.json()
                if data.get("success"):
                    self.miit_headers['Token'] = data["params"]["bussiness"]
                    self.miit_initialized = True
                    return True
            
            return False
        except Exception as e:
            logging.error(f"{FIRE_ICONS['error']} å·¥ä¿¡éƒ¨ä¼šè¯åˆå§‹åŒ–å¤±è´¥: {str(e)}")
            return False
    
    def _parse_miit_response(self, data, domain):
        """è§£æå·¥ä¿¡éƒ¨æ¥å£å“åº”"""
        if data.get("code") != 200:
            return {
                'domain': domain,
                'has_icp': False,
                'å¤‡æ¡ˆçŠ¶æ€': 'æœªå¤‡æ¡ˆ',
                'source': 'miit',
                'message': data.get("msg", "æŸ¥è¯¢å¤±è´¥")
            }
        
        records = data.get("params", {}).get("list", [])
        if not records:
            return {
                'domain': domain,
                'has_icp': False,
                'å¤‡æ¡ˆçŠ¶æ€': 'æœªå¤‡æ¡ˆ',
                'source': 'miit',
                'message': 'æœªæŸ¥è¯¢åˆ°å¤‡æ¡ˆä¿¡æ¯'
            }
        
        # æå–ä¸»åŸŸåè¿›è¡ŒåŒ¹é…
        ext = tldextract.extract(domain)
        main_domain = f"{ext.domain}.{ext.suffix}"
        matched = None
        
        for record in records:
            record_domain = record.get("domain", "").lower()
            record_ext = tldextract.extract(record_domain)
            record_main = f"{record_ext.domain}.{record_ext.suffix}"
            
            if record_main == main_domain:
                matched = record
                break
        
        if not matched:
            matched = records[0]
        
        return {
            'domain': domain,
            'has_icp': True,
            'å¤‡æ¡ˆçŠ¶æ€': 'å·²å¤‡æ¡ˆ',
            'source': 'miit',
            'license': matched.get("serviceLicence", "æœªçŸ¥"),
            'unit': matched.get("unitName", "æœªçŸ¥"),
            'unit_type': matched.get("unitType", "æœªçŸ¥"),
            'website_name': matched.get("serviceName", "æœªçŸ¥"),
            'update_time': matched.get("updateRecordTime", "æœªçŸ¥")
        }
    
    # -------------------------- å¤šæºèåˆæŸ¥è¯¢ --------------------------
    async def query_icp(self, domain):
        """å¤šæºèåˆå¤‡æ¡ˆæŸ¥è¯¢ï¼ˆä¼˜å…ˆé˜¿é‡Œäº‘ï¼Œæ¬¡é€‰å·¥ä¿¡éƒ¨ï¼‰"""
        # 1. ä¼˜å…ˆä½¿ç”¨é˜¿é‡Œäº‘æŸ¥è¯¢
        if self.aliyun_enabled:
            aliyun_result = await self.query_aliyun_icp(domain)
            if aliyun_result:
                # è‹¥é˜¿é‡Œäº‘è¿”å›æœªå¤‡æ¡ˆï¼Œå°è¯•å·¥ä¿¡éƒ¨äºŒæ¬¡ç¡®è®¤
                if not aliyun_result['has_icp']:
                    miit_result = await self.query_miit_icp(domain)
                    if miit_result and miit_result['has_icp']:
                        aliyun_result['has_icp'] = True
                        aliyun_result['å¤‡æ¡ˆçŠ¶æ€'] = 'å·²å¤‡æ¡ˆ'
                        aliyun_result['secondary_source'] = 'miit'
                        aliyun_result['message'] = 'é˜¿é‡Œäº‘æœªæŸ¥åˆ°ï¼Œå·¥ä¿¡éƒ¨ç¡®è®¤å·²å¤‡æ¡ˆ'
                return aliyun_result
        
        # 2. é˜¿é‡Œäº‘ä¸å¯ç”¨æ—¶ä½¿ç”¨å·¥ä¿¡éƒ¨
        miit_result = await self.query_miit_icp(domain)
        if miit_result:
            return miit_result
        
        # 3. æ‰€æœ‰æºå¤±è´¥
        return {
            'domain': domain,
            'has_icp': False,
            'å¤‡æ¡ˆçŠ¶æ€': 'æœªå¤‡æ¡ˆ',
            'source': 'none',
            'message': 'æ‰€æœ‰å¤‡æ¡ˆæŸ¥è¯¢æºå‡å¤±è´¥'
        }
    
    async def close(self):
        """å…³é—­ä¼šè¯"""
        if self.session:
            await self.session.close()

# -------------------------- IPä¸DNSæŸ¥è¯¢å™¨ --------------------------
class IP_DNSæŸ¥è¯¢å™¨:
    """IPä¿¡æ¯æŸ¥è¯¢ä¸DNSè§£æ"""
    def __init__(self, cache_manager):
        self.cache = cache_manager
        self.session = None
        
        # å¤šæºIPæŸ¥è¯¢API
        self.ip_apis = [
            {
                'name': 'ip-api',
                'url': 'http://ip-api.com/json/{ip}?fields=status,country,regionName,city,isp,org,as,asname,query',
                'timeout': 8
            },
            {
                'name': 'ipinfo',
                'url': 'https://ipinfo.io/{ip}/json',
                'timeout': 8
            },
            {
                'name': 'taobao',
                'url': 'https://ip.taobao.com/outGetIpInfo?ip={ip}&accessKey=alibaba-inc',
                'timeout': 6
            }
        ]
    
    async def init_session(self):
        """åˆå§‹åŒ–ä¼šè¯"""
        if not self.session:
            self.session = aiohttp.ClientSession()
        return self.session
    
    async def resolve_dns(self, domain):
        """è§£æåŸŸåDNSï¼ˆå¤šæ–¹æ³•ï¼‰- å·²åˆ é™¤URLæœ‰æ•ˆæ€§åˆ¤æ–­"""
        # å…ˆæŸ¥ç¼“å­˜
        cached = self.cache.get_cache('ip', f'dns_{domain}')
        if cached:
            return cached
        
        ips = set()
        
        # 1. ç³»ç»ŸDNSè§£æï¼ˆç›´æ¥è§£æï¼Œä¸åšURLæœ‰æ•ˆæ€§åˆ¤æ–­ï¼‰
        try:
            addr_info = socket.getaddrinfo(domain, None, socket.AF_INET)
            for info in addr_info:
                ips.add(info[4][0])
        except Exception as e:
            logging.warning(f"{FIRE_ICONS['warning']} ç³»ç»ŸDNSè§£æå¤±è´¥: {str(e)}")
        
        # 2. ç»“æœå¤„ç†
        result = {
            'domain': domain,
            'primary_ip': list(ips)[0] if ips else None,
            'ips': list(ips),
            'ip_count': len(ips),
            'is_cdn': len(ips) > 3,  # ç®€å•åˆ¤æ–­CDN
            'resolve_time': time.strftime('%Y-%m-%d %H:%M:%S')
        }
        
        # ç¼“å­˜ç»“æœ
        self.cache.set_cache('ip', f'dns_{domain}', result)
        return result
    
    async def query_ip_info(self, ip):
        """å¤šæºæŸ¥è¯¢IPä¿¡æ¯"""
        # å…ˆæŸ¥ç¼“å­˜
        cached = self.cache.get_cache('ip', f'info_{ip}')
        if cached:
            return cached
        
        session = await self.init_session()
        results = []
        
        # å¤šæºæŸ¥è¯¢
        for api in self.ip_apis:
            try:
                url = api['url'].format(ip=ip)
                async with session.get(url, timeout=api['timeout']) as resp:
                    if resp.status != 200:
                        continue
                    
                    data = await resp.json()
                    parsed = self._parse_ip_api_response(api['name'], data, ip)
                    if parsed:
                        results.append(parsed)
            except Exception as e:
                logging.warning(f"{FIRE_ICONS['warning']} {api['name']} IPæŸ¥è¯¢å¤±è´¥: {str(e)}")
        
        # èåˆç»“æœ
        if not results:
            result = {
                'ip': ip,
                'country': 'æœªçŸ¥',
                'region': 'æœªçŸ¥',
                'city': 'æœªçŸ¥',
                'isp': 'æœªçŸ¥',
                'asn': 'æœªçŸ¥',
                'as_name': 'æœªçŸ¥',
                'source': 'none'
            }
        else:
            result = self._merge_ip_results(results, ip)
        
        # ç¼“å­˜ç»“æœ
        self.cache.set_cache('ip', f'info_{ip}', result)
        return result
    
    def _parse_ip_api_response(self, api_name, data, ip):
        """è§£æIPæŸ¥è¯¢APIå“åº”"""
        if api_name == 'ip-api':
            if data.get('status') != 'success':
                return None
            return {
                'country': data.get('country', 'æœªçŸ¥'),
                'region': data.get('regionName', 'æœªçŸ¥'),
                'city': data.get('city', 'æœªçŸ¥'),
                'isp': data.get('isp', 'æœªçŸ¥'),
                'asn': data.get('as', 'æœªçŸ¥'),
                'as_name': data.get('asname', 'æœªçŸ¥'),
                'source': api_name
            }
        
        elif api_name == 'ipinfo':
            return {
                'country': data.get('country', 'æœªçŸ¥'),
                'region': data.get('region', 'æœªçŸ¥'),
                'city': data.get('city', 'æœªçŸ¥'),
                'isp': data.get('org', 'æœªçŸ¥'),
                'asn': data.get('asn', 'æœªçŸ¥').replace('AS', '') if data.get('asn') else 'æœªçŸ¥',
                'as_name': data.get('asn', 'æœªçŸ¥') if data.get('asn') else 'æœªçŸ¥',
                'source': api_name
            }
        
        elif api_name == 'taobao':
            if data.get('code') != 0:
                return None
            data = data.get('data', {})
            return {
                'country': data.get('country', 'æœªçŸ¥'),
                'region': data.get('region', 'æœªçŸ¥'),
                'city': data.get('city', 'æœªçŸ¥'),
                'isp': data.get('isp', 'æœªçŸ¥'),
                'asn': 'æœªçŸ¥',
                'as_name': 'æœªçŸ¥',
                'source': api_name
            }
        
        return None
    
    def _merge_ip_results(self, results, ip):
        """èåˆå¤šæºIPä¿¡æ¯"""
        merged = {
            'ip': ip,
            'country': [],
            'region': [],
            'city': [],
            'isp': [],
            'asn': [],
            'as_name': [],
            'sources': []
        }
        
        # æ”¶é›†æ‰€æœ‰ç»“æœ
        for result in results:
            merged['sources'].append(result['source'])
            for key in ['country', 'region', 'city', 'isp', 'asn', 'as_name']:
                if result[key] and result[key] != 'æœªçŸ¥':
                    merged[key].append(result[key])
        
        # æŒ‰å‡ºç°é¢‘ç‡é€‰æ‹©æœ€å¯èƒ½å€¼
        for key in ['country', 'region', 'city', 'isp', 'asn', 'as_name']:
            if merged[key]:
                # é€‰æ‹©å‡ºç°æ¬¡æ•°æœ€å¤šçš„å€¼
                merged[key] = max(set(merged[key]), key=merged[key].count)
            else:
                merged[key] = 'æœªçŸ¥'
        
        merged['sources'] = ', '.join(list(set(merged['sources'])))
        return merged
    
    async def close(self):
        """å…³é—­ä¼šè¯"""
        if self.session:
            await self.session.close()

# -------------------------- URLæ‰«æå™¨ï¼ˆæ ¸å¿ƒä¸šåŠ¡-åˆ é™¤URLæœ‰æ•ˆæ€§åˆ¤æ–­ï¼‰ --------------------------
class URLæ‰«æå™¨:
    """URLæ‰«ææ ¸å¿ƒï¼ˆå«è¿æ¥æ€§æ£€æŸ¥ã€å¤‡æ¡ˆæŸ¥è¯¢ã€å¨èƒåˆ†æï¼‰- å·²åˆ é™¤URLæœ‰æ•ˆæ€§åˆ¤æ–­"""
    def __init__(self, config, cache, history, right_printer):
        self.config = config
        self.cache = cache
        self.history = history
        self.right_printer = right_printer
        
        # åˆå§‹åŒ–ç»„ä»¶
        self.icp_query = ICPå¤‡æ¡ˆæŸ¥è¯¢å™¨(config, cache)
        self.ip_dns_query = IP_DNSæŸ¥è¯¢å™¨(cache)
        self.threat_analyzer = å¨èƒæƒ…æŠ¥åˆ†æå™¨(config, cache)
        
        # åŠ è½½ç³»ç»Ÿè®¾ç½®
        self.timeout = int(self.config.get_system_setting('timeout', 15))
        self.print_delay = float(self.config.get_system_setting('print_delay', 0.05))
        self.auto_save = self.config.get_system_setting('auto_save_csv', 'True') == 'True'
        
        self.results = []
    
    async def init_scanner(self):
        """åˆå§‹åŒ–æ‰«æå™¨ç»„ä»¶"""
        await self.icp_query.init_session()
        await self.ip_dns_query.init_session()
        await self.threat_analyzer.init_session()
        return True
    
    async def scan_single_url(self, url, enable_icp=True, enable_threat=True):
        """æ‰«æå•ä¸ªURL - å·²åˆ é™¤URLæœ‰æ•ˆæ€§åˆ¤æ–­"""
        # 1. æ ‡å‡†åŒ–URLï¼ˆä»…è¡¥å……åè®®ï¼Œä¸åšæœ‰æ•ˆæ€§åˆ¤æ–­ï¼‰
        normalized_url = self._normalize_url(url)
        parsed = urlparse(normalized_url)
        domain = parsed.netloc if parsed.netloc else url  # æ— åŸŸåæ—¶ç›´æ¥ä½¿ç”¨åŸå§‹URL
        logging.info(f"{FIRE_ICONS['check']} å¼€å§‹æ‰«æ: {url}")
        
        # 2. åˆå§‹åŒ–ç»“æœç»“æ„
        result = {
            'original_url': url,
            'normalized_url': normalized_url,
            'domain': domain,
            'scan_time': time.strftime('%Y-%m-%d %H:%M:%S'),
            'dns_info': {},
            'ip_info': {},
            'http_check': {},
            'https_check': {},
            'icp_info': {},
            'threat_info': {}
        }
        
        # 3. DNSè§£æï¼ˆä¸åšURLæœ‰æ•ˆæ€§åˆ¤æ–­ï¼Œç›´æ¥å°è¯•è§£æï¼‰
        logging.info(f"{FIRE_ICONS['ip']} è§£æDNS: {domain}")
        dns_result = await self.ip_dns_query.resolve_dns(domain)
        result['dns_info'] = dns_result
        
        # 4. IPä¿¡æ¯æŸ¥è¯¢
        if dns_result['primary_ip']:
            logging.info(f"{FIRE_ICONS['ip']} æŸ¥è¯¢IPä¿¡æ¯: {dns_result['primary_ip']}")
            ip_info = await self.ip_dns_query.query_ip_info(dns_result['primary_ip'])
            result['ip_info'] = ip_info
        
        # 5. HTTP/HTTPSè¿æ¥æ€§æ£€æŸ¥
        logging.info(f"{FIRE_ICONS['check']} æ£€æŸ¥è¿æ¥æ€§: {domain}")
        result['http_check'] = await self._check_protocol(normalized_url, 'http')
        result['https_check'] = await self._check_protocol(normalized_url, 'https')
        
        # 6. ICPå¤‡æ¡ˆæŸ¥è¯¢
        if enable_icp:
            logging.info(f"{FIRE_ICONS['icp']} æŸ¥è¯¢å¤‡æ¡ˆä¿¡æ¯: {domain}")
            result['icp_info'] = await self.icp_query.query_icp(domain)
        
        # 7. å¨èƒæƒ…æŠ¥åˆ†æ
        if enable_threat and dns_result['primary_ip']:
            logging.info(f"{FIRE_ICONS['threat']} åˆ†æå¨èƒæƒ…æŠ¥")
            result['threat_info']['ip'] = await self.threat_analyzer.analyze_ip(dns_result['primary_ip'])
            result['threat_info']['url'] = await self.threat_analyzer.analyze_url(normalized_url)
        
        # 8. ä¿å­˜ç»“æœ
        self.results.append(result)
        logging.info(f"{FIRE_ICONS['success']} æ‰«æå®Œæˆ: {url}")
        
        # 9. æ˜¾ç¤ºç»“æœæ‘˜è¦
        self._show_result_summary(result)
        
        return result
    
    async def scan_batch_url(self, url_list, enable_icp=True, enable_threat=True):
        """æ‰¹é‡æ‰«æURL - å·²åˆ é™¤URLæœ‰æ•ˆæ€§åˆ¤æ–­"""
        total = len(url_list)
        
        if total == 0:
            logging.error(f"{FIRE_ICONS['error']} æ— URLå¯æ‰«æ")
            return []
        
        logging.info(f"{FIRE_ICONS['check']} æ‰¹é‡æ‰«æå¼€å§‹ï¼Œå…±{total}ä¸ªURL")
        
        # å¹¶å‘æ‰«æï¼ˆæ§åˆ¶å¹¶å‘æ•°ï¼‰
        semaphore = asyncio.Semaphore(int(self.config.get_system_setting('default_workers', 3)))
        
        async def _safe_scan(url):
            async with semaphore:
                result = await self.scan_single_url(url, enable_icp, enable_threat)
                # æ§åˆ¶æ‰“å°é€Ÿåº¦
                await asyncio.sleep(self.print_delay)
                return result
        
        tasks = [_safe_scan(url) for url in url_list]
        results = await asyncio.gather(*tasks)
        
        # è¿‡æ»¤Noneç»“æœ
        self.results = [r for r in results if r is not None]
        
        # ä¿å­˜ç»“æœ
        if self.auto_save:
            self._save_results_to_csv()
        
        # ä¿å­˜å†å²
        self.history.save_history(self.results, 'batch', f'{total}_urls')
        
        # æ˜¾ç¤ºæ‰«ææ€»ç»“
        self._show_scan_summary()
        
        return self.results
    
    def _normalize_url(self, url):
        """æ ‡å‡†åŒ–URLï¼ˆä»…è¡¥å……åè®®ï¼Œä¸åšæœ‰æ•ˆæ€§åˆ¤æ–­ï¼‰"""
        url = url.strip()
        # æ— åè®®æ—¶é»˜è®¤è¡¥å……HTTPS
        if not urlparse(url).scheme:
            return f"https://{url}"
        return url
    
    async def _check_protocol(self, url, protocol):
        """æ£€æŸ¥æŒ‡å®šåè®®çš„è¿æ¥æ€§"""
        parsed = urlparse(url)
        # æ›¿æ¢åè®®ï¼ˆä¸åšURLæœ‰æ•ˆæ€§åˆ¤æ–­ï¼Œç›´æ¥å°è¯•è¿æ¥ï¼‰
        check_url = urlunparse((protocol, parsed.netloc or parsed.path, parsed.path, 
                                parsed.params, parsed.query, parsed.fragment))
        
        result = {
            'url': check_url,
            'status_code': None,
            'accessible': False,
            'response_time': 0,
            'redirect_count': 0,
            'final_url': check_url,
            'error': ''
        }
        
        try:
            start_time = time.time()
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    check_url,
                    timeout=self.timeout,
                    allow_redirects=True,
                    headers=headers,
                    ssl=False
                ) as resp:
                    result['status_code'] = resp.status
                    result['accessible'] = resp.status == 200
                    result['redirect_count'] = len(resp.history)
                    result['final_url'] = str(resp.url)
                    result['response_time'] = round(time.time() - start_time, 3)
        
        except Exception as e:
            result['error'] = str(e)
            result['response_time'] = round(time.time() - start_time, 3)
        
        return result
    
    def _save_results_to_csv(self):
        """ä¿å­˜ç»“æœåˆ°CSVï¼ˆå·¥å…·åŒç›®å½•ï¼‰"""
        if not self.results:
            logging.warning(f"{FIRE_ICONS['warning']} æ— ç»“æœå¯ä¿å­˜")
            return None
        
        # ç”ŸæˆCSVæ–‡ä»¶å
        timestamp = time.strftime('%Y%m%d_%H%M%S')
        csv_path = os.path.join(CSV_OUTPUT_DIR, f'scan_result_{timestamp}.csv')
        
        # å®šä¹‰CSVå­—æ®µï¼ˆå®Œæ•´å­—æ®µï¼‰
        fieldnames = [
            # åŸºç¡€ä¿¡æ¯
            'original_url', 'normalized_url', 'domain', 'scan_time',
            # DNSä¿¡æ¯
            'dns_primary_ip', 'dns_ips', 'dns_ip_count', 'dns_is_cdn',
            # IPä¿¡æ¯
            'ip_country', 'ip_region', 'ip_city', 'ip_isp', 'ip_asn', 'ip_as_name', 'ip_source',
            # HTTPæ£€æŸ¥
            'http_url', 'http_status', 'http_accessible', 'http_response_time', 'http_error',
            # HTTPSæ£€æŸ¥
            'https_url', 'https_status', 'https_accessible', 'https_response_time', 'https_error',
            # ICPä¿¡æ¯
            'icp_has_record', 'icp_status', 'icp_license', 'icp_unit', 'icp_source', 'icp_message',
            # å¨èƒæƒ…æŠ¥
            'threat_ip_level', 'threat_ip_rate', 'threat_url_level', 'threat_url_rate'
        ]
        
        try:
            with open(csv_path, 'w', newline='', encoding='utf-8-sig') as f:
                writer = csv.DictWriter(f, fieldnames=fieldnames)
                writer.writeheader()
                
                for result in self.results:
                    # æå–ICPä¿¡æ¯
                    icp = result['icp_info']
                    # æå–å¨èƒä¿¡æ¯
                    ip_threat = result['threat_info'].get('ip', {})
                    url_threat = result['threat_info'].get('url', {})
                    
                    writer.writerow({
                        # åŸºç¡€ä¿¡æ¯
                        'original_url': result['original_url'],
                        'normalized_url': result['normalized_url'],
                        'domain': result['domain'],
                        'scan_time': result['scan_time'],
                        # DNSä¿¡æ¯
                        'dns_primary_ip': result['dns_info'].get('primary_ip', ''),
                        'dns_ips': ', '.join(result['dns_info'].get('ips', [])),
                        'dns_ip_count': result['dns_info'].get('ip_count', 0),
                        'dns_is_cdn': result['dns_info'].get('is_cdn', False),
                        # IPä¿¡æ¯
                        'ip_country': result['ip_info'].get('country', ''),
                        'ip_region': result['ip_info'].get('region', ''),
                        'ip_city': result['ip_info'].get('city', ''),
                        'ip_isp': result['ip_info'].get('isp', ''),
                        'ip_asn': result['ip_info'].get('asn', ''),
                        'ip_as_name': result['ip_info'].get('as_name', ''),
                        'ip_source': result['ip_info'].get('sources', ''),
                        # HTTPæ£€æŸ¥
                        'http_url': result['http_check'].get('url', ''),
                        'http_status': result['http_check'].get('status_code', ''),
                        'http_accessible': result['http_check'].get('accessible', False),
                        'http_response_time': result['http_check'].get('response_time', 0),
                        'http_error': result['http_check'].get('error', ''),
                        # HTTPSæ£€æŸ¥
                        'https_url': result['https_check'].get('url', ''),
                        'https_status': result['https_check'].get('status_code', ''),
                        'https_accessible': result['https_check'].get('accessible', False),
                        'https_response_time': result['https_check'].get('response_time', 0),
                        'https_error': result['https_check'].get('error', ''),
                        # ICPä¿¡æ¯
                        'icp_has_record': icp.get('has_icp', False),
                        'icp_status': icp.get('å¤‡æ¡ˆçŠ¶æ€', 'æœªçŸ¥'),
                        'icp_license': icp.get('license', ''),
                        'icp_unit': icp.get('unit', ''),
                        'icp_source': icp.get('source', ''),
                        'icp_message': icp.get('message', ''),
                        # å¨èƒæƒ…æŠ¥
                        'threat_ip_level': ip_threat.get('risk_level', ''),
                        'threat_ip_rate': ip_threat.get('detection_rate', 0),
                        'threat_url_level': url_threat.get('risk_level', ''),
                        'threat_url_rate': url_threat.get('detection_rate', 0)
                    })
            
            logging.info(f"{FIRE_ICONS['flame']} ç»“æœå·²ä¿å­˜: {csv_path}")
            return csv_path
        except Exception as e:
            logging.error(f"{FIRE_ICONS['error']} ä¿å­˜CSVå¤±è´¥: {str(e)}")
            return None
    
    def _show_result_summary(self, result):
        """æ˜¾ç¤ºç»“æœæ‘˜è¦ï¼ˆå³ä¾§æ‰“å°ï¼‰"""
        self.right_printer.print_to_right(f"\n{FIRE_SEPARATOR}")
        self.right_printer.print_to_right(f"{FIRE_ICONS['success']} æ‰«æç»“æœ: {result['original_url']}")
        self.right_printer.print_to_right(f"{FIRE_SEPARATOR}")
        
        # åŸºç¡€ä¿¡æ¯
        self.right_printer.print_to_right(f"æ ‡å‡†åŒ–URL: {result['normalized_url']}")
        self.right_printer.print_to_right(f"æ‰«ææ—¶é—´: {result['scan_time']}")
        
        # DNSä¿¡æ¯
        dns = result['dns_info']
        self.right_printer.print_to_right(f"\n{FIRE_ICONS['ip']} DNSä¿¡æ¯:")
        self.right_printer.print_to_right(f"ä¸»IP: {dns.get('primary_ip', 'æœªçŸ¥')}")
        self.right_printer.print_to_right(f"IPæ€»æ•°: {dns.get('ip_count', 0)}")
        self.right_printer.print_to_right(f"æ˜¯å¦CDN: {'æ˜¯' if dns.get('is_cdn') else 'å¦'}")
        
        # IPä¿¡æ¯
        ip_info = result['ip_info']
        if ip_info:
            self.right_printer.print_to_right(f"\n{FIRE_ICONS['ip']} IPä¿¡æ¯:")
            self.right_printer.print_to_right(f"åœ°ç†ä½ç½®: {ip_info.get('country')} {ip_info.get('region')} {ip_info.get('city')}")
            self.right_printer.print_to_right(f"è¿è¥å•†: {ip_info.get('isp')}")
            self.right_printer.print_to_right(f"ASN: {ip_info.get('asn')} ({ip_info.get('as_name')})")
        
        # è¿æ¥æ€§æ£€æŸ¥
        self.right_printer.print_to_right(f"\n{FIRE_ICONS['check']} è¿æ¥æ€§:")
        http = result['http_check']
        https = result['https_check']
        self.right_printer.print_to_right(f"HTTP: {'å¯ç”¨' if http['accessible'] else 'ä¸å¯ç”¨'} (çŠ¶æ€ç : {http['status_code'] or 'æ— '})")
        self.right_printer.print_to_right(f"HTTPS: {'å¯ç”¨' if https['accessible'] else 'ä¸å¯ç”¨'} (çŠ¶æ€ç : {https['status_code'] or 'æ— '})")
        self.right_printer.print_to_right(f"å“åº”æ—¶é—´: HTTP {http['response_time']}s | HTTPS {https['response_time']}s")
        
        # ICPå¤‡æ¡ˆä¿¡æ¯
        icp = result['icp_info']
        if icp:
            self.right_printer.print_to_right(f"\n{FIRE_ICONS['icp']} å¤‡æ¡ˆä¿¡æ¯:")
            self.right_printer.print_to_right(f"å¤‡æ¡ˆçŠ¶æ€: {icp.get('å¤‡æ¡ˆçŠ¶æ€')}")
            if icp.get('has_icp'):
                self.right_printer.print_to_right(f"å¤‡æ¡ˆå·: {icp.get('license')}")
                self.right_printer.print_to_right(f"ä¸»åŠå•ä½: {icp.get('unit')}")
                self.right_printer.print_to_right(f"æ›´æ–°æ—¶é—´: {icp.get('update_time', 'æœªçŸ¥')}")
            self.right_printer.print_to_right(f"æŸ¥è¯¢æº: {icp.get('source')}")
        
        # å¨èƒæƒ…æŠ¥
        threat = result['threat_info']
        if threat:
            self.right_printer.print_to_right(f"\n{FIRE_ICONS['threat']} å¨èƒæƒ…æŠ¥:")
            if 'ip' in threat and threat['ip']:
                self.right_printer.print_to_right(f"IPé£é™©: {threat['ip']['risk_label']} ({threat['ip']['detection_rate']}%)")
            if 'url' in threat and threat['url']:
                self.right_printer.print_to_right(f"URLé£é™©: {threat['url']['risk_label']} ({threat['url']['detection_rate']}%)")
            if threat.get('ip', {}).get('tags'):
                self.right_printer.print_to_right(f"å¨èƒæ ‡ç­¾: {', '.join(threat['ip']['tags'][:5])}{'...' if len(threat['ip']['tags'])>5 else ''}")
        
        self.right_printer.print_to_right(f"\n{FIRE_SEPARATOR}")
    
    def _show_scan_summary(self):
        """æ˜¾ç¤ºæ‰¹é‡æ‰«ææ€»ç»“"""
        if not self.results:
            return
        
        total = len(self.results)
        accessible = sum(1 for r in self.results if r['http_check']['accessible'] or r['https_check']['accessible'])
        has_icp = sum(1 for r in self.results if r['icp_info'].get('has_icp', False))
        high_risk = sum(1 for r in self.results if r['threat_info'].get('ip', {}).get('risk_level') == 'high' or 
                       r['threat_info'].get('url', {}).get('risk_level') == 'high')
        
        self.right_printer.print_to_right(f"\n{FIRE_SEPARATOR}")
        self.right_printer.print_to_right(f"{FIRE_ICONS['success']} æ‰¹é‡æ‰«æå®Œæˆ (å…±{total}ä¸ªURL)")
        self.right_printer.print_to_right(f"{FIRE_SEPARATOR}")
        self.right_printer.print_to_right(f"å¯ç”¨URL: {accessible}/{total} ({round(accessible/total*100, 1)}%)")
        self.right_printer.print_to_right(f"å·²å¤‡æ¡ˆURL: {has_icp}/{total} ({round(has_icp/total*100, 1)}%)")
        self.right_printer.print_to_right(f"é«˜é£é™©URL: {high_risk}/{total} ({round(high_risk/total*100, 1)}%)")
        self.right_printer.print_to_right(f"{FIRE_SEPARATOR}\n")

# -------------------------- ä¸»ç¨‹åºä¸èœå•äº¤äº’ --------------------------
class ä¸»ç¨‹åº:
    """ä¸»ç¨‹åºå…¥å£ä¸èœå•äº¤äº’"""
    def __init__(self):
        # åˆå§‹åŒ–ç»„ä»¶
        self.right_printer = å³ä¾§æ‰“å°ç®¡ç†å™¨()
        self.config = é…ç½®ç®¡ç†å™¨()
        self.cache = ç¼“å­˜ç®¡ç†å™¨()
        self.history = å†å²æ•°æ®ç®¡ç†å™¨()
        self.scanner = URLæ‰«æå™¨(self.config, self.cache, self.history, self.right_printer)
        
        # åˆå§‹åŒ–Colorama
        init(autoreset=True)
        
        # åŠ è½½ç³»ç»Ÿè®¾ç½®
        self.show_banner = self.config.get_system_setting('show_banner', 'True') == 'True'
    
    def æ˜¾ç¤º_banner(self):
        """æ˜¾ç¤ºç«ç„°ä¸»é¢˜Banner"""
        if not self.show_banner:
            return
            
        print(f"\n{FIRE_COLORS['red']}=" * 60)
        print(f"{FIRE_COLORS['red']}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—{FIRE_COLORS['orange']}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— {FIRE_COLORS['yellow']}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— {FIRE_COLORS['red']}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—{FIRE_COLORS['orange']}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— {FIRE_COLORS['yellow']}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— ")
        print(f"{FIRE_COLORS['red']}â–ˆâ–ˆâ•”â•â•â•â•â•{FIRE_COLORS['orange']}â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—{FIRE_COLORS['yellow']}â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—{FIRE_COLORS['red']}â–ˆâ–ˆâ•”â•â•â•â•â•{FIRE_COLORS['orange']}â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—{FIRE_COLORS['yellow']}â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—")
        print(f"{FIRE_COLORS['red']}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  {FIRE_COLORS['orange']}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•{FIRE_COLORS['yellow']}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•{FIRE_COLORS['red']}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  {FIRE_COLORS['orange']}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•{FIRE_COLORS['yellow']}â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘")
        print(f"{FIRE_COLORS['red']}â–ˆâ–ˆâ•”â•â•â•  {FIRE_COLORS['orange']}â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—{FIRE_COLORS['yellow']}â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—{FIRE_COLORS['red']}â–ˆâ–ˆâ•”â•â•â•  {FIRE_COLORS['orange']}â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—{FIRE_COLORS['yellow']}â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘")
        print(f"{FIRE_COLORS['red']}â–ˆâ–ˆâ•‘     {FIRE_COLORS['orange']}â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘{FIRE_COLORS['yellow']}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•{FIRE_COLORS['red']}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—{FIRE_COLORS['orange']}â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘{FIRE_COLORS['yellow']}â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•")
        print(f"{FIRE_COLORS['red']}â•šâ•â•     {FIRE_COLORS['orange']}â•šâ•â•  â•šâ•â•{FIRE_COLORS['yellow']}â•šâ•â•â•â•â•â• {FIRE_COLORS['red']}â•šâ•â•â•â•â•â•â•{FIRE_COLORS['orange']}â•šâ•â•  â•šâ•â•{FIRE_COLORS['yellow']}â•šâ•â•â•â•â•â• ")
        print(f"{FIRE_COLORS['red']}=" * 60)
        print(f"{FIRE_COLORS['yellow']}  {TOOL_NAME} v{VERSION} | ä½œè€…: {AUTHOR} | æ›´æ–°: {MODIFY_TIME}")
        print(f"{FIRE_COLORS['red']}=" * 60 + f"{FIRE_COLORS['reset']}\n")
    
    def æ˜¾ç¤ºä¸»èœå•(self):
        """æ˜¾ç¤ºä¸»èœå•"""
        self.right_printer.clear_right()
        print(f"\n{FIRE_ICONS['menu']} {FIRE_COLORS['blue']}ä¸»èœå•{FIRE_COLORS['reset']}")
        print(f"{FIRE_SEPARATOR}")
        print(f"  {FIRE_COLORS['yellow']}1. å•ä¸ªURLæ‰«æ{FIRE_COLORS['reset']}")
        print(f"  {FIRE_COLORS['yellow']}2. æ‰¹é‡URLæ‰«æï¼ˆä»æ–‡ä»¶å¯¼å…¥ï¼‰{FIRE_COLORS['reset']}")
        print(f"  {FIRE_COLORS['yellow']}3. æŸ¥çœ‹å†å²è®°å½•{FIRE_COLORS['reset']}")
        print(f"  {FIRE_COLORS['yellow']}4. é…ç½®ç®¡ç†{FIRE_COLORS['reset']}")
        print(f"  {FIRE_COLORS['yellow']}5. æ¸…é™¤ç¼“å­˜{FIRE_COLORS['reset']}")
        print(f"  {FIRE_COLORS['yellow']}0. é€€å‡ºç¨‹åº{FIRE_COLORS['reset']}")
        print(f"{FIRE_SEPARATOR}")
        return input(f"{FIRE_ICONS['menu']} è¯·é€‰æ‹©åŠŸèƒ½ [0-5]: ")
    
    def é…ç½®ç®¡ç†èœå•(self):
        """é…ç½®ç®¡ç†å­èœå•"""
        while True:
            print(f"\n{FIRE_ICONS['menu']} {FIRE_COLORS['blue']}é…ç½®ç®¡ç†{FIRE_COLORS['reset']}")
            print(f"{FIRE_SEPARATOR}")
            print(f"  {FIRE_COLORS['yellow']}1. è®¾ç½®é˜¿é‡Œäº‘å¤‡æ¡ˆAPI{FIRE_COLORS['reset']}")
            print(f"  {FIRE_COLORS['yellow']}2. è®¾ç½®VirusTotal API{FIRE_COLORS['reset']}")
            print(f"  {FIRE_COLORS['yellow']}3. è®¾ç½®å¾®æ­¥æƒ…æŠ¥API{FIRE_COLORS['reset']}")
            print(f"  {FIRE_COLORS['yellow']}4. ç³»ç»Ÿè®¾ç½®{FIRE_COLORS['reset']}")
            print(f"  {FIRE_COLORS['yellow']}5. æŸ¥çœ‹å½“å‰é…ç½®{FIRE_COLORS['reset']}")
            print(f"  {FIRE_COLORS['yellow']}0. è¿”å›ä¸»èœå•{FIRE_COLORS['reset']}")
            print(f"{FIRE_SEPARATOR}")
            
            choice = input(f"{FIRE_ICONS['menu']} è¯·é€‰æ‹©é…ç½®é¡¹ [0-5]: ")
            
            if choice == '0':
                break
            elif choice == '1':
                self._è®¾ç½®é˜¿é‡Œäº‘API()
            elif choice == '2':
                self._è®¾ç½®å¨èƒæƒ…æŠ¥API('virustotal')
            elif choice == '3':
                self._è®¾ç½®å¨èƒæƒ…æŠ¥API('weibu')
            elif choice == '4':
                self._ç³»ç»Ÿè®¾ç½®()
            elif choice == '5':
                self.config.æ˜¾ç¤ºé…ç½®ä¿¡æ¯()
            else:
                print(f"{FIRE_ICONS['error']} æ— æ•ˆé€‰æ‹©ï¼Œè¯·é‡è¯•")
            
            self.right_printer.ç­‰å¾…ç”¨æˆ·æŒ‰é”®()
    
    def _è®¾ç½®é˜¿é‡Œäº‘API(self):
        """è®¾ç½®é˜¿é‡Œäº‘å¤‡æ¡ˆAPIå¯†é’¥"""
        print(f"\n{FIRE_ICONS['info']} é˜¿é‡Œäº‘å¤‡æ¡ˆAPIé…ç½®ï¼ˆéœ€æ³¨å†Œé˜¿é‡Œäº‘è´¦å·å¹¶å¼€é€šå¤‡æ¡ˆæŸ¥è¯¢æœåŠ¡ï¼‰")
        access_key_id = input("è¯·è¾“å…¥AccessKeyId: ").strip()
        access_key_secret = input("è¯·è¾“å…¥AccessKeySecret: ").strip()
        region_id = input("è¯·è¾“å…¥RegionIdï¼ˆé»˜è®¤cn-hangzhouï¼‰: ").strip() or 'cn-hangzhou'
        
        if self.config.set_aliyun_config(access_key_id, access_key_secret, region_id):
            print(f"{FIRE_ICONS['success']} é˜¿é‡Œäº‘APIé…ç½®å·²ä¿å­˜")
        else:
            print(f"{FIRE_ICONS['error']} é˜¿é‡Œäº‘APIé…ç½®ä¿å­˜å¤±è´¥")
    
    def _è®¾ç½®å¨èƒæƒ…æŠ¥API(self, api_name):
        """è®¾ç½®å¨èƒæƒ…æŠ¥APIå¯†é’¥"""
        api_names = {
            'virustotal': 'VirusTotal',
            'weibu': 'å¾®æ­¥æƒ…æŠ¥'
        }
        print(f"\n{FIRE_ICONS['info']} {api_names[api_name]} APIé…ç½®")
        api_key = input(f"è¯·è¾“å…¥{api_names[api_name]} APIå¯†é’¥: ").strip()
        
        if self.config.set_threat_api_key(api_name, api_key):
            print(f"{FIRE_ICONS['success']} {api_names[api_name]} APIé…ç½®å·²ä¿å­˜")
        else:
            print(f"{FIRE_ICONS['error']} {api_names[api_name]} APIé…ç½®ä¿å­˜å¤±è´¥")
    
    def _ç³»ç»Ÿè®¾ç½®(self):
        """ç³»ç»Ÿè®¾ç½®"""
        print(f"\n{FIRE_ICONS['info']} ç³»ç»Ÿè®¾ç½®")
        print(f"  å½“å‰é»˜è®¤å·¥ä½œçº¿ç¨‹æ•°: {self.config.get_system_setting('default_workers', '3')}")
        workers = input("è¯·è¾“å…¥æ–°çš„é»˜è®¤å·¥ä½œçº¿ç¨‹æ•°ï¼ˆ1-10ï¼‰: ").strip()
        if workers and workers.isdigit() and 1 <= int(workers) <= 10:
            self.config.set_system_setting('default_workers', workers)
        
        print(f"  å½“å‰è¶…æ—¶æ—¶é—´: {self.config.get_system_setting('timeout', '15')}ç§’")
        timeout = input("è¯·è¾“å…¥æ–°çš„è¶…æ—¶æ—¶é—´ï¼ˆ5-60ç§’ï¼‰: ").strip()
        if timeout and timeout.isdigit() and 5 <= int(timeout) <= 60:
            self.config.set_system_setting('timeout', timeout)
        
        print(f"  å½“å‰è‡ªåŠ¨ä¿å­˜CSV: {'æ˜¯' if self.config.get_system_setting('auto_save_csv') == 'True' else 'å¦'}")
        auto_save = input("æ˜¯å¦è‡ªåŠ¨ä¿å­˜CSVç»“æœï¼ˆy/nï¼‰: ").strip().lower()
        if auto_save in ['y', 'n']:
            self.config.set_system_setting('auto_save_csv', 'True' if auto_save == 'y' else 'False')
        
        print(f"{FIRE_ICONS['success']} ç³»ç»Ÿè®¾ç½®å·²æ›´æ–°")
    
    async def å•ä¸ªURLæ‰«ææµç¨‹(self):
        """å•ä¸ªURLæ‰«ææµç¨‹"""
        url = input(f"\n{FIRE_ICONS['check']} è¯·è¾“å…¥URL: ").strip()
        if not url:
            print(f"{FIRE_ICONS['error']} URLä¸èƒ½ä¸ºç©º")
            return
        
        # ç¡®è®¤æ‰«æé€‰é¡¹
        enable_icp = input(f"{FIRE_ICONS['icp']} æ˜¯å¦æŸ¥è¯¢å¤‡æ¡ˆä¿¡æ¯ï¼ˆy/nï¼Œé»˜è®¤yï¼‰: ").strip().lower() != 'n'
        enable_threat = input(f"{FIRE_ICONS['threat']} æ˜¯å¦è¿›è¡Œå¨èƒåˆ†æï¼ˆy/nï¼Œé»˜è®¤yï¼‰: ").strip().lower() != 'n'
        
        # åˆå§‹åŒ–æ‰«æå™¨
        await self.scanner.init_scanner()
        
        # æ‰§è¡Œæ‰«æ
        try:
            self.right_printer.clear_right()
            result = await self.scanner.scan_single_url(url, enable_icp, enable_threat)
            
            # ä¿å­˜å†å²
            self.history.save_history([result], 'single', url)
            
            # æ‰‹åŠ¨ä¿å­˜é€‰é¡¹
            if not self.config.get_system_setting('auto_save_csv', 'True') == 'True':
                save = input(f"{FIRE_ICONS['info']} æ˜¯å¦ä¿å­˜ç»“æœåˆ°CSVï¼ˆy/nï¼‰: ").strip().lower()
                if save == 'y':
                    self.scanner._save_results_to_csv()
        
        except Exception as e:
            logging.error(f"{FIRE_ICONS['error']} æ‰«æå¤±è´¥: {str(e)}")
        
        self.right_printer.ç­‰å¾…ç”¨æˆ·æŒ‰é”®()
    
    async def æ‰¹é‡URLæ‰«ææµç¨‹(self):
        """æ‰¹é‡URLæ‰«ææµç¨‹"""
        file_path = input(f"\n{FIRE_ICONS['check']} è¯·è¾“å…¥URLåˆ—è¡¨æ–‡ä»¶è·¯å¾„: ").strip()
        
        # éªŒè¯æ–‡ä»¶
        if not os.path.exists(file_path) or not os.path.isfile(file_path):
            print(f"{FIRE_ICONS['error']} æ–‡ä»¶ä¸å­˜åœ¨æˆ–ä¸æ˜¯æœ‰æ•ˆæ–‡ä»¶")
            return
        
        # è¯»å–URLåˆ—è¡¨
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                urls = [line.strip() for line in f if line.strip()]
            
            if not urls:
                print(f"{FIRE_ICONS['error']} æ–‡ä»¶ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆURL")
                return
            
            print(f"{FIRE_ICONS['info']} å…±è¯»å–åˆ° {len(urls)} ä¸ªURL")
        except Exception as e:
            print(f"{FIRE_ICONS['error']} è¯»å–æ–‡ä»¶å¤±è´¥: {str(e)}")
            return
        
        # ç¡®è®¤æ‰«æé€‰é¡¹
        enable_icp = input(f"{FIRE_ICONS['icp']} æ˜¯å¦æŸ¥è¯¢å¤‡æ¡ˆä¿¡æ¯ï¼ˆy/nï¼Œé»˜è®¤yï¼‰: ").strip().lower() != 'n'
        enable_threat = input(f"{FIRE_ICONS['threat']} æ˜¯å¦è¿›è¡Œå¨èƒåˆ†æï¼ˆy/nï¼Œé»˜è®¤yï¼‰: ").strip().lower() != 'n'
        
        # åˆå§‹åŒ–æ‰«æå™¨
        await self.scanner.init_scanner()
        
        # æ‰§è¡Œæ‰«æ
        try:
            self.right_printer.clear_right()
            await self.scanner.scan_batch_url(urls, enable_icp, enable_threat)
        
        except Exception as e:
            logging.error(f"{FIRE_ICONS['error']} æ‰¹é‡æ‰«æå¤±è´¥: {str(e)}")
        
        self.right_printer.ç­‰å¾…ç”¨æˆ·æŒ‰é”®()
    
    def æŸ¥çœ‹å†å²è®°å½•æµç¨‹(self):
        """æŸ¥çœ‹å†å²è®°å½•æµç¨‹"""
        while True:
            if not self.history.æ˜¾ç¤ºå†å²åˆ—è¡¨():
                self.right_printer.ç­‰å¾…ç”¨æˆ·æŒ‰é”®()
                break
            
            try:
                choice = input(f"{FIRE_ICONS['menu']} è¯·é€‰æ‹©: ").strip()
                if choice == '0':
                    break
                
                index = int(choice) - 1
                history_list = self.history.get_history_list()
                
                if 0 <= index < len(history_list):
                    history_id = history_list[index]['history_id']
                    detail = self.history.get_history_detail(history_id)
                    
                    if detail:
                        self._æ˜¾ç¤ºå†å²è¯¦æƒ…(detail)
                        self.right_printer.ç­‰å¾…ç”¨æˆ·æŒ‰é”®()
                else:
                    print(f"{FIRE_ICONS['error']} æ— æ•ˆç¼–å·")
                    self.right_printer.ç­‰å¾…ç”¨æˆ·æŒ‰é”®()
            
            except ValueError:
                print(f"{FIRE_ICONS['error']} è¯·è¾“å…¥æœ‰æ•ˆæ•°å­—")
                self.right_printer.ç­‰å¾…ç”¨æˆ·æŒ‰é”®()
            except Exception as e:
                print(f"{FIRE_ICONS['error']} æ“ä½œå¤±è´¥: {str(e)}")
                self.right_printer.ç­‰å¾…ç”¨æˆ·æŒ‰é”®()
    
    def _æ˜¾ç¤ºå†å²è¯¦æƒ…(self, detail):
        """æ˜¾ç¤ºå†å²è®°å½•è¯¦æƒ…"""
        print(f"\n{FIRE_SEPARATOR}")
        print(f"{FIRE_ICONS['flame']} {FIRE_COLORS['purple']}å†å²è¯¦æƒ… (ID: {detail['history_id']}){FIRE_COLORS['reset']}")
        print(f"{FIRE_SEPARATOR}")
        print(f"  æ‰«ææ—¶é—´: {detail['timestamp']}")
        print(f"  æ‰«æç±»å‹: {detail['scan_type']}")
        print(f"  æ‰«æç›®æ ‡: {detail['target']}")
        print(f"  ç»“æœæ•°é‡: {detail['result_count']}")
        print(f"\n{FIRE_COLORS['yellow']}æ˜¯å¦æ˜¾ç¤ºå®Œæ•´ç»“æœåˆ—è¡¨ï¼Ÿ(y/n){FIRE_COLORS['reset']}")
        
        if input().strip().lower() == 'y':
            for i, result in enumerate(detail['results'], 1):
                print(f"\n{FIRE_COLORS['orange']}----- ç»“æœ {i}/{detail['result_count']} -----{FIRE_COLORS['reset']}")
                print(f"URL: {result['original_url']}")
                print(f"å¤‡æ¡ˆçŠ¶æ€: {result['icp_info'].get('å¤‡æ¡ˆçŠ¶æ€', 'æœªçŸ¥')}")
                print(f"å¨èƒç­‰çº§: {result['threat_info'].get('ip', {}).get('risk_label', 'æœªçŸ¥')}")
                print(f"è¿æ¥çŠ¶æ€: {'å¯ç”¨' if result['http_check']['accessible'] or result['https_check']['accessible'] else 'ä¸å¯ç”¨'}")
        
        print(f"\n{FIRE_ICONS['info']} æ˜¯å¦å¯¼å‡ºè¯¥å†å²è®°å½•åˆ°CSVï¼Ÿ(y/n)")
        if input().strip().lower() == 'y':
            # ä¸´æ—¶ä¿å­˜ç»“æœå¹¶å¯¼å‡º
            self.scanner.results = detail['results']
            self.scanner._save_results_to_csv()
    
    def æ¸…é™¤ç¼“å­˜æµç¨‹(self):
        """æ¸…é™¤ç¼“å­˜æµç¨‹"""
        print(f"\n{FIRE_ICONS['info']} ç¼“å­˜ç®¡ç†")
        print(f"{FIRE_SEPARATOR}")
        print(f"  {FIRE_COLORS['yellow']}1. æ¸…é™¤ICPå¤‡æ¡ˆç¼“å­˜{FIRE_COLORS['reset']}")
        print(f"  {FIRE_COLORS['yellow']}2. æ¸…é™¤IPä¿¡æ¯ç¼“å­˜{FIRE_COLORS['reset']}")
        print(f"  {FIRE_COLORS['yellow']}3. æ¸…é™¤å¨èƒæƒ…æŠ¥ç¼“å­˜{FIRE_COLORS['reset']}")
        print(f"  {FIRE_COLORS['yellow']}4. æ¸…é™¤å…¨éƒ¨ç¼“å­˜{FIRE_COLORS['reset']}")
        print(f"  {FIRE_COLORS['yellow']}0. è¿”å›ä¸»èœå•{FIRE_COLORS['reset']}")
        print(f"{FIRE_SEPARATOR}")
        
        choice = input(f"{FIRE_ICONS['menu']} è¯·é€‰æ‹©: ").strip()
        
        if choice == '0':
            return
        elif choice == '1':
            self.cache.clear_cache('icp')
        elif choice == '2':
            self.cache.clear_cache('ip')
        elif choice == '3':
            self.cache.clear_cache('threat')
        elif choice == '4':
            confirm = input(f"{FIRE_ICONS['warning']} ç¡®å®šè¦æ¸…é™¤å…¨éƒ¨ç¼“å­˜å—ï¼Ÿ(y/n) ").strip().lower()
            if confirm == 'y':
                self.cache.clear_cache()
            else:
                print(f"{FIRE_ICONS['info']} å·²å–æ¶ˆæ¸…é™¤æ“ä½œ")
        else:
            print(f"{FIRE_ICONS['error']} æ— æ•ˆé€‰æ‹©")
        
        self.right_printer.ç­‰å¾…ç”¨æˆ·æŒ‰é”®()
    
    async def run(self):
        """ä¸»ç¨‹åºè¿è¡Œå…¥å£"""
        try:
            self.æ˜¾ç¤º_banner()
            
            while True:
                choice = self.æ˜¾ç¤ºä¸»èœå•()
                
                if choice == '0':
                    print(f"\n{FIRE_ICONS['info']} æ„Ÿè°¢ä½¿ç”¨ï¼Œå†è§ï¼")
                    self.right_printer.reset_terminal()
                    break
                elif choice == '1':
                    await self.å•ä¸ªURLæ‰«ææµç¨‹()
                elif choice == '2':
                    await self.æ‰¹é‡URLæ‰«ææµç¨‹()
                elif choice == '3':
                    self.æŸ¥çœ‹å†å²è®°å½•æµç¨‹()
                elif choice == '4':
                    self.é…ç½®ç®¡ç†èœå•()
                elif choice == '5':
                    self.æ¸…é™¤ç¼“å­˜æµç¨‹()
                else:
                    print(f"{FIRE_ICONS['error']} æ— æ•ˆé€‰æ‹©ï¼Œè¯·é‡è¯•")
                    self.right_printer.ç­‰å¾…ç”¨æˆ·æŒ‰é”®()
        
        except KeyboardInterrupt:
            print(f"\n{FIRE_ICONS['info']} ç”¨æˆ·ä¸­æ–­æ“ä½œï¼Œç¨‹åºé€€å‡º")
        except Exception as e:
            print(f"{FIRE_ICONS['error']} ç¨‹åºå‘ç”Ÿé”™è¯¯: {str(e)}")
        finally:
            # å…³é—­æ‰€æœ‰ä¼šè¯
            await self.scanner.icp_query.close()
            await self.scanner.ip_dns_query.close()
            await self.scanner.threat_analyzer.close()

# -------------------------- ç¨‹åºå…¥å£ --------------------------
if __name__ == "__main__":
    try:
        # Windowså¼‚æ­¥ç­–ç•¥ä¿®å¤
        if sys.platform.startswith('win') and sys.version_info >= (3, 8):
            asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
        
        main_app = ä¸»ç¨‹åº()
        asyncio.run(main_app.run())
    except Exception as e:
        print(f"{Fore.RED}ç¨‹åºå¯åŠ¨å¤±è´¥: {str(e)}{Style.RESET_ALL}")
        sys.exit(1)
